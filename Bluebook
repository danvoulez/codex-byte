Bluebook

UBL

**Cap√≠tulo 1/12** ‚Äî o cora√ß√£o do sistema: n√∫cleo imut√°vel, contrato est√°vel e ‚Äúreceipt-first‚Äù ponta-a-ponta.

1/12 ¬∑ N√∫cleo Imut√°vel & Contrato Est√°vel (Receipt-First)
=========================================================

Objetivo do cap√≠tulo
--------------------

Estabelecer os **invariantes** que tornam o sistema confi√°vel: tudo que entra no Gate executa `parse ‚Üí policy ‚Üí receipt` de forma determin√≠stica; nada ‚Äúnovo‚Äù √© carregado em runtime; o resultado **sempre** √© um **Receipt** verific√°vel (CID + assinatura). Tamb√©m definimos **rotas can√¥nicas com escopo**, **modelo de erro √∫nico**, **tipos Rust est√°veis** e um **kit de testes de contrato**.

* * *

Invariantes (‚Äúleis‚Äù) do n√∫cleo
------------------------------

1.  **C√≥digo est√°tico, runtime fechado**
    *   Bin√°rios `--locked`, sem `unsafe`.
    *   Pol√≠tica em **packs est√°ticos** (feature flags), sem carregamento din√¢mico.
2.  **Determinismo observ√°vel**
    *   Mesma entrada can√¥nica ‚áí mesmo CID ‚áí mesmo Receipt.
    *   Sem IO no caminho da decis√£o (sem rede/rel√≥gio/thread pr√≥pria).
3.  **Receipt-First**
    *   Toda opera√ß√£o retorna um Receipt (WA/TR/WF).
    *   O **payload bruto nunca** sai do Gate; s√≥ artefatos verificados.
4.  **Escopo em primeiro lugar**
    *   Toda chave de dados √© `app:tenant:cid`. Nada ‚Äúflutua‚Äù fora do escopo.
5.  **Erros padronizados**
    *   Uma √∫nica estrutura de erro (`AppError`) em JSON, com `code`, `message`, `request_id`, `retry_after`.

* * *

Contrato HTTP (rotas can√¥nicas + legado)
----------------------------------------

### Padr√£o can√¥nico (recomendado)

```
/a/{app}/t/{tenant}/v1/execute
/a/{app}/t/{tenant}/v1/receipt/{cid}
/a/{app}/t/{tenant}/v1/receipts
/a/{app}/t/{tenant}/v1/audit
/a/{app}/t/{tenant}/v1/transition/{cid}
```

### Legado (mapeia para `default:default`)

```
/v1/execute
/v1/receipt/{cid}
/v1/receipts
/v1/audit
/v1/transition/{cid}
```

**Observa√ß√µes importantes**

*   `{cid}` aceita `b3:` com `:` literal ou `%3A`.
*   `GET` **n√£o** exige `Content-Type`.
*   Cabe√ßalhos de CORS e Rate Limit devidamente expostos (ver Cap. 3/12 e 5/12).

* * *

Modelo de erro √∫nico (JSON)
---------------------------

```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "receipt not found",
    "request_id": "req_01HZW5‚Ä¶",
    "retry_after": 0
  }
}
```

*   Erros 4xx/5xx **sempre** nesse formato.
*   `request_id` ajuda rastreio; `retry_after` em segundos (0 se n√£o aplic√°vel).

* * *

Tipos Rust est√°veis (n√∫cleo m√≠nimo)
-----------------------------------

> Estes tipos vivem num crate central (ex.: `ubl_core`) e raramente mudam (SemVer estrito).

```rust
// scope.rs
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Scope { pub app: String, pub tenant: String }
impl Scope {
    pub fn new<A: Into<String>, T: Into<String>>(app: A, tenant: T) -> Self {
        Self { app: app.into(), tenant: tenant.into() }
    }
    pub fn key_prefix(&self) -> String { format!("a/{}/t/{}/", self.app, self.tenant) }
    pub fn scoped_cid<S: AsRef<str>>(&self, cid: S) -> String {
        format!("{}{}", self.key_prefix(), cid.as_ref())
    }
}

// receipt.rs
#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Phase { Wa, Transition, Wf }

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum Decision { Pass, Retry, Deny }

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct ReceiptV1 {
    pub scope: Scope,
    pub phase: Phase,
    /// CID can√¥nico do corpo (NRF). Ex.: "b3:abc‚Ä¶"
    pub body_cid: String,
    /// DID do runtime + fingerprint do bin√°rio (opcional)
    pub runtime_did: String,
    pub runtime_sha256: Option<String>,
    /// Envelopes e encadeamentos
    pub jws_alg: String,           // "Ed25519"
    pub jws_kid: String,           // ex.: DID
    pub jws_payload_hex: String,   // payload can√¥nico (TLV/NRF) hex
    pub parent_cid: Option<String>,// encadeamento WA‚ÜíTR‚ÜíWF
    pub decision: Decision,        // apenas em WF
    pub ts_ms: i64                 // timestamp injetado pelo Gate (host)
}
```

* * *

Pol√≠tica est√°tica (packs)
-------------------------

```rust
#[async_trait::async_trait]
pub trait Policy: Send + Sync {
    fn id(&self) -> &'static str; // ex.: "aml:v1", "pipl:v1"
    async fn decide(&self, ctx: &PolicyCtx) -> anyhow::Result<Decision>;
}

pub struct PolicyCtx<'a> {
    pub scope: &'a Scope,
    pub nrf: &'a serde_json::Value, // gram√°tica j√° can√¥nica
    pub hint: &'a PolicyHints        // sinaliza√ß√µes do pipeline
}
```

*   Lista de pol√≠ticas definida no `main()` do Gate, em ordem.
*   Primeira pol√≠tica ‚â† `PASS` **encerra** a cadeia (curto-circuito).
*   Sem IO, sem locks de longa dura√ß√£o, sem acesso a clock.

* * *

Execu√ß√£o Receipt-First (linha do tempo)
---------------------------------------

1.  **WA**: materializa inten√ß√£o ‚Äúfantasma‚Äù (antes da execu√ß√£o), CID gerado.
2.  **Transition**: prova de salto RB‚ÜíœÅ (VM/pipeline can√¥nicos), CID gerado.
3.  **WF**: decis√£o final (PASS/RETRY/DENY).
4.  **Persist√™ncia**: cada fase persiste no ledger **escopado** (`a/{app}/t/{tenant}/`).
5.  **Evento**: publicar `ReceiptEvent` (Cap. 6/12) ap√≥s persist√™ncia (at-least-once).

* * *

Regras de CORS (alto n√≠vel, detalhes no Cap. 3/12)
--------------------------------------------------

*   `AllowOrigin::predicate` resolve `Scope` **a partir do path**, inclusive **pr√©-flight**.
*   Ordem de resolu√ß√£o: `(app,tenant)` ‚Üí `(app,*)` ‚Üí `global`.
*   Sem depend√™ncia de autentica√ß√£o para decidir CORS.

* * *

Idempot√™ncia e Rate Limit (alto n√≠vel)
--------------------------------------

*   **Idempot√™ncia** por `(app,tenant,method,path,idemp_key)` + `body_sha` (LRU+TTL).
*   **Rate Limit** por `(app,tenant,client_id)` com headers expostos no CORS.
*   Casos ‚ÄúReplay/Progress/Expired/Evict‚Äù cobertos por testes (Cap. 5/12).

* * *

Contrato de verifica√ß√£o (CLI e UI)
----------------------------------

*   CLI `ublx verify` deve aceitar: `--cid`, `--did`, `--payload`, `--sig`.
*   UI exibe **motivos para confiar** e guia ‚Äúcomo verificar‚Äù (sem expor payload).
*   ‚ÄúCopy All‚Äù inclui `links.self` para deep-link verific√°vel.

* * *

Kit de testes de contrato (m√≠nimo indispens√°vel)
------------------------------------------------

1.  **Roteamento `{cid}` (b3:)**
    *   `GET /a/app/t/ten/v1/receipt/b3:‚Ä¶` ‚áí 200 | 404 JSON
    *   Aceita `b3:%3A‚Ä¶` idem.
    *   `Content-Type` ignorado em `GET`.
2.  **Escopo**
    *   `execute` em `A:X` n√£o aparece em `A:Y` nem em `B:*`.
    *   `receipts` e `audit` retornam apenas chaves `app:tenant:cid`.
3.  **Determinismo**
    *   Mesma entrada can√¥nica ‚áí mesmo CID/Receipt (10x).
    *   `ghost:true` evita colis√£o de idempot√™ncia na prova.
4.  **Pol√≠ticas**
    *   `PASS` por padr√£o; regras simples gerando `RETRY` e `DENY`.
    *   Curto-circuito garantido (primeira decis√£o finaliza).
5.  **Erros**
    *   401/403/404/429/5xx retornam `AppError` JSON.
    *   `request_id` sempre presente.
6.  **CORS**
    *   Preflight com `Origin` permitido no `(app,tenant)` e fallback `(app,*)`/global.
    *   `Vary` correto.
7.  **Idempot√™ncia & Rate**
    *   `Replay` com mesmo `Idempotency-Key`.
    *   Limites isolados por escopo.

* * *

Exemplos de payloads (simplificados)
------------------------------------

### `POST /a/acme/t/pro/v1/execute`

```json
{
  "manifest": {
    "pipeline": "doc-officialize",
    "in_grammar": {"inputs":{"doc":""},"mappings":[],"output_from":"doc"},
    "out_grammar":{"inputs":{"doc":""},"mappings":[],"output_from":"doc"},
    "policy": {"allow": true}
  },
  "vars": {"doc": "Proposta v1"},
  "options": {"ghost": true}
}
```

### `200 OK` (WF)

```json
{
  "decision": "PASS",
  "tip_cid": "b3:f749‚Ä¶8ae0",
  "links": {
    "self": "https://gate/a/acme/t/pro/v1/receipt/b3:f749‚Ä¶8ae0",
    "verify": "https://gate/a/acme/t/pro/v1/verify/b3:f749‚Ä¶8ae0"
  },
  "runtime": { "did": "did:key:z6Mk‚Ä¶", "sha256": "9c5e‚Ä¶"},
  "policy_trace": [{"id":"allow-all:v1","decision":"PASS"}]
}
```

* * *

Checklist de implanta√ß√£o segura (Gate)
--------------------------------------

*    Compilar com `--release --locked` e registrar `sha256` em metadata.
*    Ativar **auth** por padr√£o (dev token mapeado para `default:default`).
*    CORS por escopo habilitado (predicate lendo path).
*    Idempot√™ncia LRU+TTL e Rate Limit `(app,tenant,client)` ativos.
*    M√©tricas Prometheus e tracing com spans essenciais.
*    EventBus configurado (publica√ß√£o ap√≥s persist√™ncia).

* * *

Sa√≠da esperada deste cap√≠tulo
-----------------------------

*   Crate `ubl_core` com **Scope**, **ReceiptV1**, **Policy** e **AppError**.
*   Rotas `{cid}` migradas para `{}` (Axum 0.7) e legado mapeado para `default:default`.
*   Middleware de CORS (predicate com escopo), Idempot√™ncia, Rate Limit ligados.
*   Testes de contrato m√≠nimos rodando em CI.

* * *

No pr√≥ximo cap√≠tulo (**2/12 ¬∑ Persist√™ncia & Ledger**) eu fecho o desenho de **armazenamento imut√°vel**, index de chaves `app:tenant:cid`, migra√ß√£o ‚Äúlegacy ‚Üí scoped‚Äù, e preparo a base para o **EventBus** (cap. 6/12). Quer que eu siga direto?

## Prompt:
2

## Response:
Aqui vai o **Cap√≠tulo 2/12** ‚Äî **Persist√™ncia Imut√°vel, Ledger & √çndices**. Bora ‚Äúassentar o ch√£o‚Äù para escalar com seguran√ßa, mantendo o modelo receipt-first impec√°vel. üöÄ

2/12 ¬∑ Persist√™ncia & Ledger (CAS, escopo forte, migra√ß√£o e testes)
===================================================================

Objetivo do cap√≠tulo
--------------------

Definir como cada artefato do pipeline √© **persistido de forma imut√°vel**, com **namespace por escopo (`app:tenant`)**, garantindo **reprodutibilidade, recupera√ß√£o** e **indexa√ß√£o** eficientes. Tamb√©m cobrimos migra√ß√£o do modo legado, pol√≠ticas de reten√ß√£o/GC e testes de integridade.

* * *

1) Modelo de dados: ‚Äútudo √© um chip‚Äù
------------------------------------

Princ√≠pio: todo artefato persistido √© **conte√∫do-endere√ßado** por **CID** (BLAKE3 multibase). O _escopo_ √© parte do endere√ßo l√≥gico para isolar dados por **{app, tenant}**.

### Tipos de artefato

*   **NRF (payload can√¥nico)**: entrada e sa√≠das can√¥nicas em TLV/JSON can√¥nico.
*   **Receipt**: WA / Transition / WF, contendo encadeamento, `runtime_sha256`, `jws`, etc.
*   **Transition proof**: evid√™ncias do salto RB‚ÜíœÅ (separado ou incluso no receipt).
*   **Runtime release**: metadados do bin√°rio certificado (DID + SHA-256).
*   **√çndices auxiliares**: chaves compactas para listagens, buscas e auditoria.

* * *

2) Layout do Ledger (S3-compat, ex.: Garage)
--------------------------------------------

Armazenamos em um bucket √∫nico (p.ex. `ubl-ledger`) usando **paths determin√≠sticos**:

```
a/{app}/t/{tenant}/
  nrf/
    {cid}                          # conte√∫do can√¥nico (NRF)
  receipt/
    wa/{cid}.json                  # recibos WA
    tr/{cid}.json                  # recibos Transition
    wf/{cid}.json                  # recibos WF (decis√£o)
  trans/
    {cid}.proof.json               # (opcional) provas de transi√ß√£o
  runtime/
    {runtime_sha256}.json          # manifesto do runtime certificado
  index/
    by-time/{YYYY}/{MM}/{DD}/{HH}/{cid}.idx   # para varreduras temporais
    by-decision/{PASS|RETRY|DENY}/{cid}.idx   # atalhos de auditoria
    heads/{cid}.idx                 # ‚Äúpontos de ponta‚Äù (WF) do encadeamento
```

**Observa√ß√µes**

*   O **CID** √© calculado sobre o conte√∫do can√¥nico. Para recibos, usamos **CID do corpo (body\_cid)** do pr√≥prio receipt JSON **normalizado**.
*   O _escopo_ (app/tenant) n√£o altera o CID (imutabilidade global), mas define **onde** o artefato mora e **quem** enxerga.

* * *

3) Chaves de leitura/escrita (escopo forte)
-------------------------------------------

No Gate, toda opera√ß√£o resolve um `Scope`:

```rust
let key = scope.scoped_cid(cid); // "a/{app}/t/{tenant}/" + cid
```

*   **Escrita**: sempre para o _namespace_ do escopo.
*   **Leitura**: primeiro no namespace do escopo; jamais ‚Äúvazar‚Äù para outro escopo.
*   **Legado**: `/v1/*` mapeia para `default:default` (cap. 1/12). Usado somente como compat.

* * *

4) Fluxo de persist√™ncia receipt-first
--------------------------------------

1.  **WA** (inten√ß√£o ‚Äúfantasma‚Äù)
    *   Persiste `nrf/{wa_body_cid}` + `receipt/wa/{wa_body_cid}.json`
    *   Publica √≠ndice temporal `index/by-time/.../wa_body_cid.idx`
2.  **Transition**
    *   Persiste `receipt/tr/{tr_body_cid}.json` (+ `trans/{tr_body_cid}.proof.json` se existir)
    *   Atualiza `index/by-time` (+ opcional `by-decision` se sua pol√≠tica j√° marca algo)
3.  **WF** (decis√£o final)
    *   Persiste `receipt/wf/{wf_body_cid}.json`
    *   Atualiza `index/by-decision/{decision}/{wf_body_cid}.idx`
    *   Marca ‚Äúhead‚Äù do encadeamento: `index/heads/{wf_body_cid}.idx`

> **Regra**: publicar eventos (EventBus) **depois** que a escrita persistente retornar `OK` (at-least-once).

* * *

5) √çndices & consultas
----------------------

Os √≠ndices s√£o **arquivos vazios ou JSON m√≠nimo** (baratos), usados como _ponteiros_:

*   `index/by-time/‚Ä¶/{cid}.idx` ‚Üí lista por janela de tempo.
*   `index/by-decision/PASS/{cid}.idx` ‚Üí auditorias r√°pidas de conformidade.
*   `index/heads/{wf_cid}.idx` ‚Üí facilitar `GET /receipt/{cid}` e pagina√ß√µes de ‚Äú√∫ltimos WF‚Äù.

### Consulta t√≠pica

*   **GET √∫ltimo WF do app/tenant nas √∫ltimas N horas**:
    1.  "expandir" `index/by-time/YYYY/MM/DD/HH` dentro da janela
    2.  ordenar por nome de arquivo (ou por metadata S3) desc
    3.  bater em `index/heads/‚Ä¶` para garantir que √© ‚Äúponta‚Äù
    4.  retornar a lista de `cid` ‚Üí carregar `receipt/wf/{cid}.json`

* * *

6) Migra√ß√£o ‚ÄúLegado ‚Üí Scoped‚Äù
-----------------------------

Para repos que hoje guardam em mem√≥ria ou em `default:default`:

1.  **Backfill** (offline)
    *   Ler `receipts` antigos do armazenamento anterior (ou mem√≥ria/dump).
    *   Para cada receipt, **recomputar** `body_cid` (confirma integridade).
    *   **Escrever** nos novos paths em `a/{app}/t/{tenant}/...` (usa mapa `cid ‚Üí scope` conforme origem).
    *   Gerar √≠ndices `by-time`, `by-decision`, `heads`.
2.  **Sinaliza√ß√£o** (feature flag rollout)
    *   Gate passa a usar **somente** o armazenamento scoped para escrita/leitura.
    *   Rotas legadas continuam resolvendo `default:default` somente se ativado.
3.  **Verifica√ß√£o**
    *   Rodar **provas determin√≠sticas**: para amostras, fazer `GET` antigo vs novo e garantir `cid` e `decision` iguais.
    *   Auditoria de amostragem `N%` com hash de conte√∫do.

* * *

7) Integridade & seguran√ßa
--------------------------

*   **WAL local** (Write-Ahead Log): opcional, para aumentar robustez em queda de energia/rede; flush ass√≠ncrono para S3.
*   **Digest duplo**: armazenar `sha256` do Receipt no metadata do objeto S3 (`x-amz-meta-sha256`) facilita checagem r√°pida.
*   **Assinatura JWS**: o campo `jws` do Receipt cobre o payload can√¥nico. Verifica√ß√£o √© offline, sem depender do S3.
*   **Server-side encryption**:
    *   Se Garage suportar SSE nativa, habilitar; sen√£o, **envelopes** de criptografia por objeto (KMS externo ou chave de tenant).
*   **Retention / WORM**:
    *   Pol√≠ticas de bucket (S3 Object Lock) para imutabilidade de X dias/meses em ambientes regulados.
*   **Versionamento**:
    *   Ativar versionamento do bucket (barato, √∫til contra dele√ß√£o acidental).
*   **ACLs & IAM**:
    *   Gate usa **credencial √∫nica** com permiss√£o _apenas_ ao prefixo `a/{app}/t/{tenant}/‚Ä¶` quando for multi-tenant por credencial; em single-tenant, compartilha mas nunca exp√µe credencial ao cliente.

* * *

8) GC, reten√ß√£o e _pinning_
---------------------------

*   **Receipts**: por padr√£o **n√£o** sofrem GC (prova hist√≥rica).
*   **NRF**: eleg√≠vel a GC quando:
    *   N√£o referenciado por nenhum Receipt ‚Äúvivo‚Äù (contabilidade via refer√™ncia reversa opcional).
    *   Pol√≠ticas de reten√ß√£o do tenant (ex.: ‚Äúdescartar NRF WA ap√≥s 90 dias‚Äù).
*   **Pinning**:
    *   `a/{app}/t/{tenant}/pin/{cid}` (arquivo vazio) indica **n√£o GC**.
    *   Consumidores (indexer) podem ‚Äúpin‚Äù para reprocessar ou manter proje√ß√µes.

* * *

9) Desempenho & custos
----------------------

*   **Batch**: uploads em lote (multi-part) para recibos grandes (raros).
*   **Compress√£o**: `Content-Encoding: zstd` para NRFs grandes (se cliente/infra permitir) ou compress√£o transparente no SDK (sem alterar CID do _conte√∫do can√¥nico_).
*   **Hot storage vs Cold**:
    *   Receipts WF recentes em _hot tier_; WA/TR e NRF antigos podem ir para _cold tier_.
*   **√çndices finos**:
    *   Pequenos, baratos e majoritariamente ‚Äúappend-only‚Äù; evitamos _tables_ complexas.

* * *

10) Testes de persist√™ncia (contrato)
-------------------------------------

### Unidade

*   `cid_is_stable_for_same_content`
*   `scoped_key_prefix_is_correct`
*   `receipt_roundtrip_json_is_canonical`
*   `index_paths_are_deterministic`

### Integra√ß√£o (com S3 local)

*   `put_nrf_then_receipts_wa_tr_wf ‚Üí list_by_time_contains_all`
*   `get_wf_by_cid_returns_complete_trace`
*   `legacy_path_maps_to_default_scope_only_when_enabled`
*   `sse_and_metadata_digest_present` (se SSE habilitada)
*   `worm_retention_blocks_delete` (se objeto travado)

### E2E (via Gate)

*   `execute ‚Üí three receipts persisted ‚Üí wf head visible`
*   `multi-tenant_isolation_on_keys_and_lists`
*   `migration_backfill_keeps_cids`
*   `event_published_only_after_persist_ok` (ver cap. 6/12)

* * *

11) Opera√ß√£o & observabilidade
------------------------------

*   **M√©tricas**
    *   `ledger_put_seconds{kind="nrf|wa|tr|wf"}`
    *   `ledger_errors_total{stage=...}`
    *   `ledger_bytes_written_total`
    *   `index_write_seconds`
*   **Tracing**
    *   spans: `ledger.put`, `ledger.get`, `index.write`, `index.scan`, com `cid`, `scope` e `bytes`.
*   **Alertas**
    *   P95/99 de `ledger.put_seconds`
    *   Taxa de erro por est√°gio (WA/TR/WF)
    *   ‚ÄúOut of order‚Äù (evento sem persist√™ncia) ‚Üí **n√£o deve ocorrer**

* * *

12) APIs administrativas (CLI/SDK)
----------------------------------

*   `ublx ledger put-nrf --file f.json --scope a:tenant`
*   `ublx ledger get-receipt --cid b3:‚Ä¶ --scope ‚Ä¶`
*   `ublx ledger list --by-time --from -24h --scope ‚Ä¶`
*   `ublx ledger verify-receipt --cid b3:‚Ä¶` (bate `sha256`, `jws`, `runtime_sha256`)
*   `ublx migrate backfill --from dump.ndjson --scope-map map.json`

> A **UI futura** consome as mesmas rotas ou shell out para `ublx` (mirror), mantendo coer√™ncia (cap. 1/12).

* * *

13) Plano de migra√ß√£o seguro (passo-a-passo)
--------------------------------------------

1.  **Read-only mirror**: habilitar leitura do novo ledger em paralelo (feature flag).
2.  **Dual-write**: Gate grava no **scoped** e no legado (somente por curto per√≠odo).
3.  **Verifica√ß√£o**: amostragem di√°ria de recibos (`N%`) comparando CIDs/decis√µes.
4.  **Cutover**: desligar escrita no legado; manter leitura de emerg√™ncia por X dias.
5.  **Arquivamento**: snapshot do legado; documenta√ß√£o de ‚Äúrollback steps‚Äù.
6.  **GC legado**: ap√≥s reten√ß√£o m√≠nima, apagar.

* * *

14) Riscos & mitiga√ß√£o
----------------------

*   **Diverg√™ncia can√¥nica** (lib de JSON/TLV muda):  
    ‚Üí ‚ÄúGolden tests‚Äù versionados; _pin_ de vers√µes; `runtime_sha256` no receipt.
*   **Clock do host** influencia `ts_ms`:  
    ‚Üí `ts_ms` √© **metadado**, n√£o entra no CID do corpo can√¥nico.
*   **S3 eventual** impacta lista imediata:  
    ‚Üí Index `by-time` gravado de forma consistente antes do publish de evento.
*   **Chaves IAM muito amplas**:  
    ‚Üí Minimizar escopo via prefix; auditorias autom√°ticas de pol√≠ticas.

* * *

15) Sa√≠das deste cap√≠tulo
-------------------------

*   Layout do bucket e fun√ß√µes de utilidade implementadas (put/get/list por escopo).
*   Escrita WA/TR/WF + √≠ndices `by-time`, `by-decision`, `heads`.
*   CLI/SDK para verifica√ß√£o e backfill.
*   Testes de unidade/integra√ß√£o/E2E rodando no CI.
*   Guia de migra√ß√£o aplicado em _dev_ e _staging_.

* * *

Se estiver ok, sigo com o **Cap√≠tulo 3/12 ‚Äì CORS, Autentica√ß√£o e Rate/Idempot√™ncia**: predicate consciente de **path/escopo**, preflight correto sem auth, headers expostos e testes de ataque (origem inv√°lida, wildcard tightening). Quer que eu avance?

## Prompt:
3

## Response:
Aqui vai o **Cap√≠tulo 3/12 ‚Äî CORS, Autentica√ß√£o e Defesa de Per√≠metro**. Foco: **predicate CORS consciente de escopo**, **preflight sem atrito**, **AuthN/AuthZ por Scope**, **Rate Limit + Idempot√™ncia** coerentes com o modelo _receipt-first_.

3/12 ¬∑ CORS, Auth e Per√≠metro (Scope-aware, test√°vel e m√≠nimo)
==============================================================

Objetivo do cap√≠tulo
--------------------

1.  Tornar o **CORS determin√≠stico por escopo** (`app`, `tenant`) e seguro em **preflight**.
2.  Consolidar **AuthN/AuthZ** no Gate, extraindo **Scope** do path e dos **tokens**.
3.  Unificar **Rate Limiter** e **Idempot√™ncia** com _keys_ escopo-aware e sem falso positivo.
4.  Entregar **testes de ataque** e **contratos de erro JSON**.

* * *

1) Predicado CORS ‚ÄúScope-aware‚Äù
-------------------------------

### 1.1 Escopo no path

Rotas ‚Äúnovas‚Äù (escopadas):

```
/a/{app}/t/{tenant}/v1/execute
/a/{app}/t/{tenant}/v1/receipt/{cid}
/a/{app}/t/{tenant}/v1/receipts
```

Fallback legado (mapeia p/ `default:default`): `/v1/*`.

### 1.2 Modelo de configura√ß√£o

```rust
/// Config hier√°rquica: (app, tenant) ‚Üí (app, *) ‚Üí global
pub struct CorsConfig {
    pub global_allowed: Vec<String>,
    pub app_allowed: HashMap<String, Vec<String>>,
    pub app_tenant_allowed: HashMap<(String,String), Vec<String>>,
}

impl CorsConfig {
    pub fn is_origin_allowed(&self, origin: &str, scope: Option<&Scope>) -> bool {
        if let Some(s) = scope {
            if let Some(list) = self.app_tenant_allowed.get(&(s.app.clone(), s.tenant.clone())) {
                return list.iter().any(|o| o == origin);
            }
            if let Some(list) = self.app_allowed.get(&s.app) {
                return list.iter().any(|o| o == origin);
            }
        }
        self.global_allowed.iter().any(|o| o == origin)
    }
}
```

### 1.3 Predicado AllowOrigin

*   **Para requests normais** (GET/POST‚Ä¶): resolve `Scope` do path e avalia `Origin`.
*   **Para preflight (OPTIONS)**: extrai o mesmo **Scope do path** (sem depender de Auth) e avalia `Origin`.
*   **Headers expostos** (ex.: `x-ratelimit-*`, `retry-after`) definidos uma √∫nica vez.

Pseudoc√≥digo no _builder_ do Axum:

```rust
let cors = CorsLayer::new()
  .allow_origin(AllowOrigin::predicate(move |origin, req_parts| {
      let origin = match origin.to_str() { Ok(s) => s, Err(_) => return false };
      // resolve escopo a partir do path, inclusive em OPTIONS
      let scope = parse_scope_from_path(req_parts.uri.path());
      state.cors_config.is_origin_allowed(origin, scope.as_ref())
  }))
  .allow_methods([Method::GET, Method::POST, Method::OPTIONS])
  .allow_headers([CONTENT_TYPE, AUTHORIZATION])
  .expose_headers(["x-ratelimit-limit","x-ratelimit-remaining","retry-after"]);
```

### 1.4 Preflight: regras

*   **Nunca exigir Auth** no **OPTIONS** preflight.
*   **Responder 204** r√°pido quando `Origin` e `Access-Control-Request-Method` forem v√°lidos para o escopo.
*   **Negar (403)** com JSON consistente quando inv√°lido (evitar `text/plain`).

* * *

2) AuthN/AuthZ coesas com Scope
-------------------------------

### 2.1 Tokens e Scope

*   **AuthN**: `Authorization: Bearer <token>`.
*   **ClientInfo** decodificado ‚Üí `client_id`, `app`, `tenants[]`, `roles[]`, _ttl_.
*   **Scope do path** √© **fonte de verdade**; o token precisa **autorizar** aquele par `(app, tenant)`.

Regra:

*   Se **Scope** do path ‚â† um dos escopos do token ‚Üí **403** `{"code":"forbidden_scope",...}`.
*   No **legado** (`/v1/*`), usar `default:default` e aplicar as mesmas regras.

### 2.2 Modo convite (cap. de onboarding vir√° adiante)

*   **Convite por e-mail** gera _claim_ tempor√°ria (JWS) que amarra `user_email ‚Üí {app,tenant,roles}`.
*   Se o usu√°rio j√° est√° autenticado ao aceitar, **n√£o** pedir c√≥digos: basta **aceite**.

### 2.3 Erros padronizados (JSON)

Criar `AppError` √∫nico:

```json
{ "code": "forbidden_scope", "message": "Token not allowed for scope a:X/t:Y", "request_id":"...", "retry_after":0 }
```

Outros c√≥digos: `unauthorized`, `cors_denied`, `rate_limited`, `idempotent_replay`, `invalid_cid`, `not_found`.

* * *

3) Rate Limiting e Idempot√™ncia (defesa dupla)
----------------------------------------------

### 3.1 Chaves ‚ÄúScope-aware‚Äù

*   **Rate limit key**: `rl:{app}:{tenant}:{client_id}:{method}:{path}`
*   **Idempotency key**: `idem:{app}:{tenant}:{method}:{path}:{idempotency_key}` + **hash(body)**.

### 3.2 Pol√≠tica de Rate

*   **Janela deslizante** por `(app, tenant, client)`; limites configur√°veis por plano.
*   **Headers**:
    *   `x-ratelimit-limit`, `x-ratelimit-remaining`.
    *   `retry-after` para bloqueios.
*   **Escalada**: _burst_ pequeno + m√©dia por janela ‚Üí reduz falsos positivos.

### 3.3 Idempot√™ncia

*   **POST** exige header opcional `Idempotency-Key` (recomendado para clientes).
*   Armazenar **(hash do corpo, status, wf\_cid, expira√ß√£o)**.
*   Replays com **mesmo key** e **mesmo hash** ‚Üí **200** com mesmo resultado; **hash diferente** ‚Üí **409**.
*   TTL curto (ex.: 10‚Äì30 min) com **LRU + monotonic seq** para desempate determin√≠stico (evita flakiness de `Instant`).

* * *

4) Fluxos de preflight e execu√ß√£o
---------------------------------

### 4.1 Preflight (CORS)

1.  **OPTIONS** `/a/x/t/y/v1/execute` + headers CORS.
2.  Predicado extrai `{x,y}`, checa `Origin` contra `CorsConfig`.
3.  Se ok ‚Üí **204** com `Access-Control-Allow-*`; sen√£o **403 JSON**.

### 4.2 Execu√ß√£o autenticada

1.  **POST** com Bearer.
2.  Middleware Auth resolve `ClientInfo` e valida `Scope`.
3.  **Idempotency** (se presente) ‚Üí early return se replay.
4.  **Rate limit**.
5.  **Runtime** (determin√≠stico) ‚Üí gera WA/TR/WF.
6.  **Persist√™ncia** (cap. 2/12), **publish** (cap. 6/12).
7.  **Resposta**: WF Receipt + headers de cota.

* * *

5) Testes (ataque, unidade, integra√ß√£o, E2E)
--------------------------------------------

### 5.1 CORS

*   **Preflight v√°lido**: `Origin` permitido por `(app,tenant)` ‚Üí 204 + allow headers.
*   **Preflight inv√°lido**: `Origin` n√£o permitido ‚Üí 403 JSON `cors_denied`.
*   **Request sem `Origin`** (curl/backend) ‚Üí permitido (CORS s√≥ p/ browsers).
*   **Wildcard tightening**: garantir que `*` **n√£o** cobre endpoints **autenticados**; exigir lista expl√≠cita.

### 5.2 Auth

*   **Bearer v√°lido** com escopo certo ‚Üí 200.
*   **Bearer v√°lido** com escopo errado ‚Üí 403 `forbidden_scope`.
*   **Sem token** em endpoint protegido ‚Üí 401 `unauthorized`.
*   **Legado**: `/v1/*` com token que n√£o inclui `default:default` ‚Üí 403.

### 5.3 Rate

*   **Exaust√£o**: ultrapassar N reqs/intervalo ‚Üí 429 `rate_limited`, com `retry-after`.
*   **Headers** corretos em requests abaixo do limite.

### 5.4 Idempot√™ncia

*   **Mesmo `Idempotency-Key` + mesmo corpo** ‚Üí replay 200 igual, sem reexecutar runtime.
*   **Mesmo `Idempotency-Key` + corpo diferente** ‚Üí 409.
*   **TTL** expirado ‚Üí trata como novo.
*   **LRU eviction** determin√≠stico (teste com seq monot√¥nico).

### 5.5 E2E ‚Äúataque front‚Äù

*   **Origem maliciosa** tentando `fetch` ‚Üí barrado em preflight.
*   **CORS permissivo em global**, mas `app_tenant` mais restrito ‚Üí respeitar o mais espec√≠fico.
*   **OPTIONS com headers inv√°lidos** (m√©todo n√£o permitido) ‚Üí 403.

* * *

6) Observabilidade e SLOs
-------------------------

*   **Tracing**: `cors.check`, `auth.validate`, `rate.check`, `idem.check`.
*   **M√©tricas**:
    *   `gate_cors_denied_total`
    *   `gate_auth_forbidden_scope_total`
    *   `gate_rate_limited_total`
    *   `gate_idem_replay_total`
*   **SLO**: P99 de `POST /execute` ‚â§ 200 ms (sem fila). Alertar se `rate_limited_total` crescer > X/min.

* * *

7) Contratos de erro (√∫nicos, consistentes)
-------------------------------------------

Sempre JSON:

```json
{ "code":"cors_denied", "message":"Origin not allowed for scope a:X/t:Y", "request_id":"...", "retry_after":0 }
```

*   **Nunca** `text/plain` em 4xx/5xx.
*   **`request_id` obrigat√≥rio** para correla√ß√£o.

* * *

8) CLI/SDK ‚Äî ergonomia e testes
-------------------------------

*   **CLI p√∫blica (`ublx`)**:
    *   `ublx exec --scope a:X/t:Y --idempotency abc --file payload.json`
    *   Mostra `x-ratelimit-*`, indica replay (icone / nota).
*   **Tests CLI**:
    *   Bateria ‚Äúbattle‚Äù cobre CORS (com `curl -H Origin`), Auth (401/403/200), Rate (429), Idem (200/409).
*   **SDKs TS/Py**:
    *   _Interceptor_ adiciona `Idempotency-Key` auto (hash do corpo se n√£o houver).
    *   Retorna _typed errors_ a partir de `code`.

* * *

9) Seguran√ßa pr√°tica
--------------------

*   **Sem Auth em OPTIONS**; **com Auth** em m√©todos ‚Äúfortes‚Äù.
*   **Cookies**: desabilitar por padr√£o (preferir Bearer); se necess√°rio, `SameSite=Strict`, `Secure`.
*   **CORS por Scope** evita que um app ‚ÄúA‚Äù injete front contra tenant ‚ÄúB‚Äù.
*   **Registros de decis√£o** (WF) **nunca** embutem segredos; segredos ficam em adapters out-of-band e/ou cifrados.

* * *

10) Roadmap curto (para este cap√≠tulo)
--------------------------------------

1.  Finalizar **predicate CORS** com `parse_scope_from_path()` (inclui OPTIONS).
2.  Padronizar **AppError JSON** e revisar handlers que ainda retornam `text/plain`.
3.  Ligar **Rate** + **Idem** com _keys_ escopo-aware; expor headers.
4.  Escrever **tests** (unit/integration/E2E) listados acima.
5.  Atualizar **docs**: matriz de decis√µes, exemplos de preflight, exemplos de erros.

* * *

11) ‚ÄúGotchas‚Äù que quebram f√°cil
-------------------------------

*   Rotas com `{cid}` usando `:` no valor ‚Üí garantir que **n√£o** conflitem com parsers antigos; j√° padronizado em Axum `{}`.
*   Middleware de `Content-Type` **n√£o** deve rejeitar **GET** sem header (comportamento idempotente).
*   CORS **global muito amplo** ‚Üí torne **(app,tenant)** can√¥nico; global s√≥ para _dev_.
*   Idempot√™ncia sem hash do corpo ‚Üí replays incorretos.

* * *

12) Crit√©rios de aceite
-----------------------

*   ‚úÖ Preflight v√°lido/negado por escopo, 100% testado.
*   ‚úÖ Todos 4xx/5xx em **JSON** com `code`.
*   ‚úÖ Rate/Idem com _keys_ contendo `(app,tenant)` e **testes determin√≠sticos**.
*   ‚úÖ SDK/CLI exibem `x-ratelimit-*` e detectam replay.
*   ‚úÖ Observabilidade com m√©tricas e spans para per√≠metro.

Se estiver ok, sigo para o **Cap√≠tulo 4/12 ‚Äî Pipeline de Execu√ß√£o e Policies (purismo + packs est√°ticos)**, cobrindo assinatura do _runtime_, cadeia WA‚ÜíTR‚ÜíWF, _feature flags_ e contratos de Policy. Quer que eu avance?

## Prompt:
4

## Response:
Aqui vai o **Cap√≠tulo 4/12 ‚Äî Pipeline Determin√≠stico e Policies (WA ‚Üí TR ‚Üí WF)**. Foco: contrato imut√°vel das fases, _packs est√°ticos_ de pol√≠ticas, assinatura do runtime, e testes que garantem reprodutibilidade entre arquiteturas.

4/12 ¬∑ Execu√ß√£o determin√≠stica e cadeia de Policies
===================================================

Objetivo do cap√≠tulo
--------------------

1.  Padronizar o **contrato WA/TR/WF** (estruturas, hashing, CIDs).
2.  Fixar o **runtime certificado** (hash/attestation) no recibo.
3.  Empacotar **policies est√°ticas** (compile-time), sem IO, sem ‚Äúsurpresas‚Äù.
4.  Entregar **testes e invariantes** que sustentam o receipt-first.

* * *

1) Fases do pipeline: contrato can√¥nico
---------------------------------------

### 1.1 Tipos (est√°veis, em `ubl_core`)

```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum Phase { WA, TR, WF }

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct Scope { pub app: String, pub tenant: String } // j√° usado no gate

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct ReceiptV1 {
    pub scope: Scope,
    pub phase: Phase,
    pub body_cid: String,          // CID do conte√∫do can√¥nico da fase
    pub parent: Option<String>,    // body_cid da fase anterior (WA<-TR<-WF)
    pub runtime: RuntimeTag,       // hash/attestation do bin√°rio em uso
    pub policy_trace: Vec<PolicyStep>,
    pub decision: Decision,        // PASS | RETRY | DENY (apenas em WF)
    pub ts: i64,                   // instante de emiss√£o (injetado pelo gate)
    pub sig_cid: String,           // CID do JWS (assinatura) da fase
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PolicyStep {
    pub id: &'static str, // ex.: "aml:v1"
    pub outcome: Decision,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum Decision { PASS, RETRY, DENY }

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct RuntimeTag {
    pub algo: &'static str,  // "sha256"
    pub digest_hex: String,  // 64 hex chars
    pub did: String,         // did:key do runtime/fornecedor
}
```

### 1.2 CIDs: regra √∫nica

*   **Entrada de cada fase** vira **JSON can√¥nico NRF-1** ‚Üí **BLAKE3** ‚Üí `b3:<multibase>`.
*   `body_cid` √© do **payload** da fase, n√£o do `ReceiptV1`.
*   `sig_cid` √© do **JWS** (assinatura) que envolve `(scope, phase, body_cid, parent, runtime, policy_trace, decision?, ts)`.

Invariantes:

*   `WA.parent == None`
*   `TR.parent == Some(WA.body_cid)`
*   `WF.parent == Some(TR.body_cid)`

* * *

2) Runtime certificado (bin√°rio imut√°vel)
-----------------------------------------

### 2.1 Carimbo do runtime

*   Build com `--locked`, `--release`, `#![forbid(unsafe_code)]`.
*   Calcular **SHA-256 do ELF** no CI (x86 e ARM).
*   Publicar `RuntimeTag { algo:"sha256", digest_hex, did }` no ledger e **referenciar** em cada `ReceiptV1`.

### 2.2 Attestation opcional

*   Se houver TEE: incluir `tee.report_cid` dentro do `body` WF e adicionar no `policy_trace` um passo `attestation:PASS/DENY`.
*   Nunca bloquear a cadeia por aus√™ncia do TEE (feature flag separada).

* * *

3) Policies: packs est√°ticos, sem IO
------------------------------------

### 3.1 Trait e execu√ß√£o

```rust
#[async_trait::async_trait]
pub trait Policy: Send + Sync {
    fn id(&self) -> &'static str;
    async fn decide(&self, ctx: &PolicyCtx) -> anyhow::Result<Decision>;
}

pub struct PolicyCtx<'a> {
    pub scope: &'a Scope,
    pub manifest: &'a serde_json::Value, // input can√¥nico
    pub runtime: &'a RuntimeTag,
}
```

Regras:

*   **Ordem determin√≠stica** de avalia√ß√£o (lista fixa).
*   Primeira n√£o-PASS **encerra** a decis√£o do WF.
*   **Sem IO**: sem rede, sem rel√≥gio; usar somente o `manifest` (can√¥nico) e o `scope`.

### 3.2 Registro em compile-time

```rust
pub fn policy_pipeline() -> &'static [&'static dyn Policy] {
    // feature-gated
    &[
        #[cfg(feature="policy-aml")] &AML_V1,
        #[cfg(feature="policy-pii")] &PII_STRICT_V1,
        &DEFAULT_ALLOW, // sempre por √∫ltimo
    ]
}
```

### 3.3 Motivos de ‚Äústatic-only‚Äù

*   Evita **c√≥digo arbitr√°rio** em produ√ß√£o.
*   Garante **hash do runtime** est√°vel (repro).
*   Simplifica **auditoria** (packs versionados e assinados).

* * *

4) Execu√ß√£o: WA ‚Üí TR ‚Üí WF (fun√ß√µes puras + boundary host)
---------------------------------------------------------

### 4.1 Montagem das fases (alto n√≠vel)

```rust
pub struct ExecInputs { pub scope: Scope, pub manifest: serde_json::Value }

pub async fn execute(inputs: ExecInputs) -> anyhow::Result<(ReceiptV1, ReceiptV1, ReceiptV1)> {
    // WA
    let wa_body = canonicalize_wa(&inputs.manifest)?;
    let wa = sign_phase(&inputs.scope, Phase::WA, None, &wa_body).await?;

    // TR (prova RB‚ÜíœÅ)
    let tr_body = prove_rb_to_rho(&wa_body)?; // puramente determin√≠stico
    let tr = sign_phase(&inputs.scope, Phase::TR, Some(wa.body_cid.clone()), &tr_body).await?;

    // WF (decis√£o final)
    let (wf_body, trace, decision) = decide_with_policies(&inputs.scope, &tr_body).await?;
    let mut wf = sign_phase(&inputs.scope, Phase::WF, Some(tr.body_cid.clone()), &wf_body).await?;
    wf.policy_trace = trace;
    wf.decision = decision;
    Ok((wa, tr, wf))
}
```

### 4.2 ‚ÄúBoundary host‚Äù (Gate)

*   Injeta `ts` e `runtime` no `ReceiptV1` **antes de assinar**.
*   Persiste `WA/TR/WF` na store **escopada** (`a/{app}/t/{tenant}/‚Ä¶`).
*   Publica eventos de **TR** e **WF** (cap. 6/12).
*   Retorna **apenas** WF ao cliente por padr√£o; WA/TR sob demanda.

* * *

5) Persist√™ncia m√≠nima (imut√°vel e escopada)
--------------------------------------------

Layout no ledger (S3/CAS):

```
a/{app}/t/{tenant}/r/wa/{wa.body_cid}.json
a/{app}/t/{tenant}/r/tr/{tr.body_cid}.json
a/{app}/t/{tenant}/r/wf/{wf.body_cid}.json
a/{app}/t/{tenant}/jws/{receipt.sig_cid}.json   # envelopes
```

Proje√ß√£o opcional (para leitura r√°pida):

```
a/{app}/t/{tenant}/idx/tip/{wf.body_cid} -> {wa, tr, wf}
```

* * *

6) Erros e invariantes (sempre JSON)
------------------------------------

C√≥digos relevantes (cap. 3/12 unifica):

*   `invalid_manifest` (NRF n√£o can√¥nico)
*   `policy_violation` (WF=DENY, com `policy_trace`)
*   `retry_suggested` (WF=RETRY, incluir hints determin√≠sticos)
*   `proof_mismatch` (TR inv√°lido contra WA)
*   `runtime_mismatch` (tag n√£o bate com bin√°rio entregue)

Invariantes testados:

*   Reexecutar `execute()` sobre **mesmo manifest** ‚Üí **mesmos CIDs** (x86/ARM).
*   `parent` correto entre fases.
*   `policy_trace` **idempotente** (mesma ordem/sa√≠da).

* * *

7) Testes (n√≠veis e vetores)
----------------------------

### 7.1 Unit (runtime/policies)

*   Canonicaliza√ß√£o NRF ‚Üí CID est√°vel com amostras de strings, mapas ordenados, floats exatos.
*   Policies com **tabelas** (table-driven): entradas e sa√≠das PASS/RETRY/DENY.
*   TR prova: WA‚ÜíTR _round-trip_ n√£o altera sem√¢ntica.

### 7.2 Integration (gate + ledger fake)

*   `POST /execute` mesma carga 10x ‚Üí **mesmo tip** (sem idempotency-key, usar `ghost:true` para evitar 409 de idempot√™ncia do gate).
*   GET tip ‚Üí cadeia completa (com/sem proje√ß√£o `idx/tip`).
*   Corrup√ß√£o simulada em um arquivo ‚Üí `proof_mismatch`.

### 7.3 Cross-arch

*   Gera√ß√£o de vetores em **x86** e **ARM**; comparar CIDs e `sig_cid`.
*   Se divergir: teste falha com relat√≥rio do primeiro byte discrepante.

### 7.4 Linhas vermelhas

*   Nenhuma policy pode acessar `std::time::SystemTime::now()` diretamente (use `ts` do gate no envelope apenas).
*   Sem `rand`/`thread_rng` dentro do runtime/policies.

* * *

8) SDK/CLI: ergonomia determin√≠stica
------------------------------------

*   CLI: `ublx exec --scope a:X/t:Y --manifest m.json --out wf.json`
    *   Flag `--include wa,tr` para depura√ß√£o.
    *   Mostra `policy_trace` tabelado; em `DENY`, imprimir ‚Äúpolicy:motivo‚Äù.
*   SDKs: expor `verify(receipt)`
    *   Recalcula `body_cid`, verifica `sig_cid`, valida `parent`.
    *   Opcionalmente baixa WA/TR a partir do `tip` para reconstruir a cadeia.

* * *

9) Observabilidade
------------------

Spans obrigat√≥rios:

*   `runtime.canonicalize_wa`
*   `runtime.prove_rb_to_rho`
*   `policy.decide[{id}]` (com tag outcome)
*   `gate.sign_phase`, `gate.persist`, `gate.publish`

M√©tricas:

*   `gate_receipt_emitted_total{phase}`
*   `gate_policy_outcome_total{policy_id,outcome}`
*   `gate_execute_seconds_bucket` (P50/P95/P99)

* * *

10) Migra√ß√£o segura (se houver legado din√¢mico)
-----------------------------------------------

1.  Congelar loader din√¢mico (feature‚Äêflag retirado do build).
2.  Introduzir packs est√°ticos equivalentes.
3.  Rodar _shadow_ por 1 semana: executar **ambos** e comparar `WF.decision`.
4.  Se 100% ok, remover c√≥digo din√¢mico.

* * *

11) ‚ÄúGotchas‚Äù comuns
--------------------

*   **Floats**: sempre serializar em forma can√¥nica e evitar NaN/Inf (rejeitar no parse).
*   **Ordena√ß√£o de chaves**: map JSON **ordenado** por chave; nunca depender de `serde_json::Map` aleat√≥rio.
*   **CIDs em URL** com `:`: rotas Axum devem usar `{cid}` (n√£o `:cid`).
*   **Assinatura**: assinar o **envelope** (`ReceiptV1`), n√£o apenas o corpo.

* * *

12) Crit√©rios de aceite
-----------------------

*   ‚úÖ Reexecu√ß√£o bit-a-bit: **mesmos CIDs** (x86/ARM).
*   ‚úÖ `parent` encadeado corretamente (WA‚ÜêTR‚ÜêWF).
*   ‚úÖ `policy_trace` determin√≠stico e audit√°vel.
*   ‚úÖ Todos erros em **JSON** com `code`.
*   ‚úÖ Vetores cross-arch publicados no repo (fixtures) e usados no CI.

Se quiser, j√° trago um **pacote m√≠nimo de policies** (ex.: `pii:strict`, `aml:v1`, `size:limit`) com casos de teste e vetores para usar de base no reposit√≥rio.

## Prompt:
Leia as mensagens anteriores, e continue, agora eh a 5

5) Idempot√™ncia (LRU+TTL) Est√°vel
Middleware com chave (app,tenant,method,path,idemp_key) + body_sha. Corrija ordem determin√≠stica com seq monot√¥nico (evita empates de Instant). Tests: New/Replay/Progress/Expired/Evict.

## Response:
Aqui vai o **Cap√≠tulo 5/12 ‚Äî Idempot√™ncia (LRU + TTL) Est√°vel**. Foco: chaveamento por escopo + m√©todo + caminho + idemp\_key + hash do corpo; estados New/Progress/Replay/Expired/Evict; corre√ß√£o de empates via **sequ√™ncia monot√¥nica**; testes.

5/12 ¬∑ Idempot√™ncia determin√≠stica e previs√≠vel
===============================================

Objetivo do cap√≠tulo
--------------------

1.  Definir a **chave** de idempot√™ncia com consci√™ncia de escopo.
2.  Especificar a **m√°quina de estados** (New/Progress/Replay/Expired/Evict).
3.  Implementar **LRU + TTL** com resolu√ß√£o determin√≠stica (seq).
4.  Expor **contrato HTTP** (headers) e c√≥digos.
5.  Cobrir **testes de unidade/integrados** e casos de contorno.

* * *

1) Chave can√¥nica (escopo + m√©todo + caminho + idempotency-key + body\_sha)
---------------------------------------------------------------------------

A idempot√™ncia deve ser ‚Äúexata o suficiente‚Äù para repetir apenas o que for realmente a mesma inten√ß√£o:

```
Key = H(
  scope.app, scope.tenant,
  method, path,                     // path normalizado (sem query-string)
  idempotency_key,                  // obrigat√≥rio p/ m√©todos mutantes (POST/PUT/PATCH/DELETE)
  body_sha256                       // payload can√¥nico (NRF-1) ou SHA do corpo bruto
)
```

Regras:

*   `idempotency_key`: obrigat√≥rio nos endpoints mutantes. Se ausente, o **gate** pode:
    *   (A) negar (400 `missing_idempotency_key`), ou
    *   (B) aceitar apenas com `ghost:true` (sem efeitos colaterais), conforme pol√≠tica.
*   `body_sha256`: se o endpoint recebe **JSON can√¥nico**, use o SHA do JSON can√¥nico (ap√≥s normaliza√ß√£o). Caso contr√°rio, use SHA do corpo bruto.
*   `path`: sem query-string; par√¢metros din√¢micos **j√° resolvidos** (ex.: `/a/{app}/t/{tenant}/v1/execute`).

* * *

2) M√°quina de estados
---------------------

Para cada `Key`, o store mant√©m:

```rust
enum IdempCheck {
  New,        // primeira vez
  Progress,   // j√° em execu√ß√£o (em outra thread/processo)
  Replay {    // j√° houve resposta final (200/4xx/5xx definitivos)
    status: u16,
    etag: Option<String>,
    location: Option<String>,
    body_cid: Option<String>, // dica p/ re-hidratar
  },
  Expired,    // registro existe, mas TTL venceu ‚Äî tratar como New (e renovar)
  Evict,      // pol√≠tica de LRU expulsou ‚Äî tratar como New (regravar)
}
```

Estados persistidos:

*   `Pending` ‚Üí criado no in√≠cio da execu√ß√£o; cont√©m `created_at`, `seq`, `body_hash`.
*   `Final { status, etag?, location?, body_cid? }` ‚Üí gravado ao concluir com sucesso/falha.
*   `Stale/Expired` ‚Üí `created_at + ttl < now`.

**Transi√ß√µes**:

*   `New` ‚Üí grava `Pending` (CAS: s√≥ se n√£o existe).
*   `Progress` ‚Üí retorna 409 (`retry_after`) com cabe√ßalhos de ‚Äútrava amig√°vel‚Äù.
*   `Replay` ‚Üí retorna **a mesma resposta** (status e metadados); corpo pode ser re-hidratado via `body_cid`/cache.
*   `Expired | Evict` ‚Üí tratar como `New` (regravar `Pending` e seguir fluxo normal).

* * *

3) LRU + TTL com ordem determin√≠stica (seq monot√¥nico)
------------------------------------------------------

Problema cl√°ssico: entradas criadas ‚Äúno mesmo instante‚Äù podem empatar ao escolher a v√≠tima de LRU. Solu√ß√£o:

*   Guardar `(created_at: Instant, seq: u64)` e ordenar por `(created_at, seq)`; `seq` √© um contador **global e monot√¥nico** do store.
*   Em concorr√™ncia, `seq` √© incrementado sob **Mutex/RwLock** (barreira curta) ou com `AtomicU64` + fetch\_add.

Estrutura (simplificada):

```rust
pub struct EntryMeta {
  pub created_at: Instant,
  pub seq: u64,
}

pub enum Entry {
  Pending { meta: EntryMeta, body_sha: [u8; 32] },
  Final   { meta: EntryMeta, status: u16, etag: Option<String>, location: Option<String>, body_cid: Option<String> },
}

pub struct IdempotencyStore {
  ttl: Duration,
  cap: usize,
  seq: AtomicU64,
  map: HashMap<Key, Entry>,
}
```

Evic√ß√£o:

*   Quando `map.len() >= cap`, selecionar a **menor** `(created_at, seq)` entre entradas que **n√£o est√£o em Progress** (ou seja, `Pending` tamb√©m pode ser vitimada se desejado, mas recomendo priorizar expulsar `Final`).
*   Para seguran√ßa contra _thundering herd_, considerar uma **janela de prote√ß√£o**: n√£o evictar `Pending` com `created_at < now + grace_ms`.

TTL:

*   `Expired`: `now - created_at > ttl`. Ao detectar, tratar como `New` e sobrescrever.

* * *

4) Middleware (ordem e sem√¢ntica)
---------------------------------

Ordem sugerida no stack do Axum:

1.  **Scope extractor** (resolve `/a/{app}/t/{tenant}/‚Ä¶`)
2.  **Auth** (se houver)
3.  **Content-Type guard** (s√≥ para m√©todos com corpo)
4.  **Idempotency** (antes do handler mutante)
5.  **Rate-limit** (opcional antes/depois; se antes, ajuda a conter DDoS sem ‚Äúsujar‚Äù o store)
6.  **Handler**
7.  **Idempotency finalize** (grava `Final` a partir do resultado)

Pseudo:

```rust
// before
match store.check(scope, method, path, idemp_key, body_sha) {
  New | Expired | Evict => proceed_and_mark_pending(),
  Progress => return http_409_with_retry_after(),
  Replay { status, etag, location, body_cid } => return rebuild_response(...),
}

// after (on success or handled failure)
store.finalize(key, status, etag, location, body_cid);
```

**Importante**: ‚Äúfalhas definitivas‚Äù (4xx/5xx n√£o transit√≥rios) **devem** gerar `Replay` (mesma resposta).  
Falhas ‚Äúquentes‚Äù (ex.: 503 upstream) ‚Äî opcional: n√£o finalizar para permitir nova tentativa (fica em `Pending` com timeout).

* * *

5) Contrato HTTP
----------------

### Requisi√ß√£o

*   `Idempotency-Key: <opaque>` (obrigat√≥rio p/ mutantes)
*   `X-Body-SHA256: <hex>` (opcional; se ausente e corpo JSON can√¥nico, o gate calcula; sen√£o, rejeita 400)

### Respostas

*   **409 Conflict** (Progress)
    *   `Retry-After: <segundos>` (ex.: 2)
    *   `Idempotency-Key: <mesmo>`
    *   `X-Idempotency-State: progress`
*   **2xx/4xx/5xx** (Final/Replay)
    *   `Idempotency-Key: <mesmo>`
    *   `X-Idempotency-State: replay|final`
    *   `ETag: <etag>` (se houver)
    *   `Location: <url>` (se houver)
*   **400** (erros de contrato)
    *   `missing_idempotency_key`
    *   `body_hash_mismatch` (se header fornecido n√£o bate com corpo)
    *   `invalid_key_format` (opcional)

* * *

6) Concurrency e atomicidade
----------------------------

*   **CAS** de `Pending`: use `map.entry(key).or_insert_with(...)` sob lock; se j√° existir `Pending/Final`, devolva `Progress/Replay`.
*   **Finalize**: substituir atomically `Pending ‚Üí Final`.
*   **Crash safety**: se o processo cair entre `Pending` e `Final`, a entrada fica em `Progress` at√© `ttl` ‚Üí depois vira `Expired` e novas tentativas entram como `New`.

* * *

7) Testes (unit√°rios + integrados)
----------------------------------

### 7.1 Unit ‚Äî `idempotency.rs`

*   `new_then_progress`: primeira chamada ‚Üí `New`, segunda antes do finalize ‚Üí `Progress`.
*   `final_then_replay`: ap√≥s `finalize`, pr√≥xima chamada ‚Üí `Replay{status,..}` e **mesmos cabe√ßalhos**.
*   `expired_becomes_new`: avan√ßa o rel√≥gio al√©m do TTL ‚Üí `Expired` ‚Üí tratar como `New`.
*   `lru_eviction_is_deterministic`: inserir `cap+2` entradas **no mesmo instante**; com `seq` monot√¥nico, a v√≠tima √© **determin√≠stica**.
*   `body_sha_mismatch`: se header n√£o bate, 400 e **n√£o grava** `Pending`.
*   `no_idempotency_key_mutating`: POST sem cabe√ßalho ‚Üí 400 (ou 202 ghost-only conforme modo escolhido).
*   `replay_preserves_status_bodycid`: checa persist√™ncia de `status`, `etag`, `location`, `body_cid`.

### 7.2 Integrados ‚Äî `gate` (Axum)

*   `POST /execute` com mesmo `Idempotency-Key` e **mesmo** corpo:
    *   1¬™ ‚Üí 200 + `X-Idempotency-State: final`
    *   2¬™ (imediata) ‚Üí 200 + `X-Idempotency-State: replay` (sem executar runtime/policies).
*   `POST /execute` mesma key **corpo diferente** ‚Üí 409 `body_hash_mismatch` (ou 422), n√£o muda store.
*   `progress_window`: disparar duas requisi√ß√µes concorrentes; uma recebe 200 e outra 409 com `Retry-After`.
*   `ttl_rollover`: simular queda do processo; ap√≥s TTL, nova chamada segue como `New`.

* * *

8) Observabilidade
------------------

M√©tricas:

*   `gate_idemp_check_total{state}` ‚Äî contagem por `New|Progress|Replay|Expired|Evict`.
*   `gate_idemp_entries{status="pending|final"}` ‚Äî _gauge_.
*   `gate_idemp_evictions_total` ‚Äî contagem de evic√ß√µes.

Tracing:

*   `idemp.check` (tags: hash\_prefix, state)
*   `idemp.finalize` (tags: status, etag\_present, location\_present)

* * *

9) Seguran√ßa e DoS
------------------

*   **Limitar** tamanho do corpo antes de calcular SHA (pre-flight via `Content-Length`).
*   **Cap** ajust√°vel e **TTL** curto (ex.: 2‚Äì5 min) para endpoints quentes.
*   **Keys** muito longas ‚Üí truncar/hashear antes de usar como parte da chave.
*   **Scope-aware** garante isolamento entre tenants/apps.

* * *

10) Compatibilidade
-------------------

*   Endpoints **idempotentes por natureza** (GET/HEAD) **n√£o** usam store (short-circuit).
*   Para `PUT` com ETag, o `Replay` devolve o mesmo ETag/Location, preservando sem√¢ntica HTTP.
*   `Location`/`body_cid` ajudam o cliente a reidratar resposta sem reprocessar.

* * *

11) Par√¢metros de ambiente
--------------------------

```
IDEMP_TTL_SECS=180
IDEMP_CAP=10000
IDEMP_FINALIZE_ON_5XX=false   # se true, 5xx tamb√©m viram Replay
```

* * *

12) Crit√©rios de aceite
-----------------------

*   ‚úÖ Sem empates n√£o determin√≠sticos: pol√≠tica de LRU sempre previs√≠vel (seq).
*   ‚úÖ `Replay` bit-a-bit: mesma resposta (status, ETag, Location).
*   ‚úÖ `Progress` previs√≠vel em corrida, com `Retry-After`.
*   ‚úÖ Cobertura de testes: New/Replay/Progress/Expired/Evict/body-mismatch.
*   ‚úÖ M√©tricas e spans expostos.

Se quiser, eu preparo o patch final para o `IdempotencyStore` com a interface `check()/finalize()` e o middleware de Axum, junto com o kit de testes (unit + integ) j√° no padr√£o do reposit√≥rio.

## Prompt:
Agora eh a 6

6) Rate Limit por Escopo
Atualize o limitador para (app,tenant,client_id) e exponha cabe√ßalhos X-RateLimit-* no CORS. Tests: burst, refill, e isolamento entre tenants.

7) Receipt API √† Prova de ‚Äúb3:‚Äù
Garanta que GET /v1/receipt/{cid} aceita b3:... sem exigir Content-Type. Respostas JSON padronizadas via AppError (code, message, request_id, retry_after). Tests cobrindo b3: e CIDs inexistentes.

8) ‚ÄúBattle Script‚Äù end-to-end
Rode gate com auth ligada; crie sempre user ‚Üí app ‚Üí tenant via CLI p√∫blica/admin (sem atalhos). Cen√°rios: determinismo com ghost:true, CORS em tr√™s camadas, audit report, /receipts e /audit antes/depois, e isolamento entre dois tenants.

9) CLI P√∫blica como Fonte da Verdade
Fa√ßa a UI e testes integrais consumirem exatamente o que a CLI consome (mesmo contrato). Se houver descompasso CLI admin ‚Üî API, abra issue ‚Äúalignment‚Äù com: contrato esperado, contrato atual, e teste reprodutor.

10) EventBus (Iggy) Plug√°vel
Ap√≥s persistir (ledger), publique ReceiptEvent { scope, phase, cid, parent, decision, ts }. Trait EventBus com impl IggyEventBus. Tests: at-least-once (reprocessamento idempotente), parti√ß√£o por app:tenant.

11) Observabilidade Base
Tracing spans (gate.request, policy.decide, runtime.exec, ledger.put, event.publish), Prometheus (pass/deny/retry; hist de exec), e dashboard m√≠nimo. Testes de m√©tricas: exporta e conta passa.

12) Receipt UI (Canvas) ‚Üí Integra√ß√£o
A p√°gina do canvas j√° est√° est√°vel (corrigido o ) no copy). Pr√≥ximos passos:
	‚Ä¢	Ligar ?cid=... ‚Üí fetch real, com ‚ÄúDemo Mode‚Äù quando sem cid.
	‚Ä¢	‚ÄúVerify‚Äù abrir guia com instru√ß√µes (CLI ublx verify + libs).
	‚Ä¢	Testes leves j√° existem; adicione: PASS/RETRY/DENY altera progress, popovers acess√≠veis (aria), ‚ÄúCopy All‚Äù inclui links.self, e modo impress√£o exibe faixa de autenticidade.

## Response:
Thought for 4 seconds

Aqui vai o **Cap√≠tulo 6/12 ‚Äî Rate Limit por Escopo**. Objetivo: tornar o limitador **consistente com o modelo de escopo** e observ√°vel, sem atrito com CORS, idempot√™ncia e auth.

6/12 ¬∑ Rate limit por (app, tenant, client\_id)
===============================================

1) Chave de limita√ß√£o (Scope-aware)
-----------------------------------

```
RateKey = H(
  scope.app, scope.tenant,          // extra√≠do do path /a/{app}/t/{tenant}/...
  client_id,                         // do token (auth) ou "anonymous" (quando permitido)
  method,                            // opcional (p.ex. diferenciar GET vs POST)
  route_id                           // opcional: ID est√°vel da rota p/ granularidade
)
```

Regras:

*   **client\_id**: vem do middleware de auth. Para dev token/CLI, usar um `client_id` fixo (ex.: `dev:cli`).
*   Requests **sem escopo** (legacy `/v1/*`) mapeiam para `app=default, tenant=default`.
*   Opcional: **burst buckets** separados por m√©todo (ex.: GET possui limites mais altos).

* * *

2) Algoritmo: Token-Bucket com janela deslizante
------------------------------------------------

*   **Token Bucket** (refill cont√≠nuo) ‚Üí baixa lat√™ncia e comportamento previs√≠vel sob burst.
*   Estrutura por chave:
    ```rust
    struct Bucket {
      capacity: u32,         // ex.: 100
      refill_per_sec: f32,   // ex.: 20 tokens/s
      tokens: f32,
      last_refill: Instant,
    }
    ```
*   A cada request: `tokens = min(capacity, tokens + Œît * refill_per_sec)`.
    *   Se `tokens >= cost` ‚Üí aceita, `tokens -= cost` (cost default = 1).
    *   Sen√£o ‚Üí **429 Too Many Requests** + `Retry-After`.

**Custos diferenciados**:

*   `GET/HEAD` cost 1, `POST/PUT/PATCH` cost 2‚Äì5 (opcional).
*   Endpoints cr√≠ticos (ex.: `/execute`) podem ter **classe de bucket** pr√≥pria.

* * *

3) Cabe√ßalhos HTTP (expostos via CORS)
--------------------------------------

Responder SEMPRE (aceito ou 429) com:

*   `X-RateLimit-Limit: <capacidade>`
*   `X-RateLimit-Remaining: <restante arredondado>`
*   `X-RateLimit-Reset: <epoch_seconds>` (quando o bucket volta a >= 1 token)
*   Em 429, adicionar `Retry-After: <segundos>`

CORS:

*   No `CorsLayer`, incluir em `expose_headers`:
    ```
    x-ratelimit-limit,x-ratelimit-remaining,x-ratelimit-reset,retry-after
    ```
*   Preflight (`OPTIONS`) **n√£o** consome tokens, mas deve **espelhar** limites da rota-alvo quando poss√≠vel (opcional).

* * *

4) Integra√ß√£o no stack
----------------------

Ordem sugerida (Axum):

1.  **Scope extractor** (resolve app/tenant a partir do path)
2.  **Auth** (preenche `client_id`)
3.  **Content-Type guard** (se aplic√°vel)
4.  **Idempotency check (read)** ‚Äì n√£o consome tokens em `Replay`
5.  **Rate Limit** ‚Üê AQUI (consome tokens apenas se o request vai executar)
6.  **Handler**
7.  **Idempotency finalize**
8.  **AppError mapper** (uniformiza JSON)

Regras de intera√ß√£o:

*   Se `Idempotency::Replay`, **n√£o** debitar bucket (resposta de cache l√≥gico).
*   Se `Idempotency::Progress`, retornar 409 e **n√£o** debitar.
*   Em **DENY** de policy (4xx), j√° debitou (correto: o request existiu).
*   Em erro 5xx transit√≥rio, decidir se debita (padr√£o: **sim**, para conter ‚Äúmartelada‚Äù).

* * *

5) Configura√ß√£o (env) por escopo
--------------------------------

Permitir defaults e overrides:

```
# Defaults globais
RATE_CAPACITY=100
RATE_REFILL_PER_SEC=20

# Overrides por app:tenant (chave = "app,tenant")
RATE_OVERRIDE__myapp,acme__CAPACITY=300
RATE_OVERRIDE__myapp,acme__REFILL_PER_SEC=60

# Overrides por client_id (mais espec√≠fico que escopo)
RATE_CLIENT__partner:foo__CAPACITY=600
RATE_CLIENT__partner:foo__REFILL_PER_SEC=120
```

Resolu√ß√£o (ordem): `client_id override` ‚Üí `(app,tenant) override` ‚Üí `global default`.

* * *

6) API de middleware (esqueleto)
--------------------------------

```rust
pub struct RateLimiter {
  store: DashMap<RateKey, Bucket>,
  now: fn() -> Instant,        // injet√°vel p/ testes
}

impl RateLimiter {
  pub fn check(&self, key: &RateKey, cost: f32) -> Decision {
    let mut b = self.store.entry(key.clone()).or_insert_with(|| self.make_bucket(key)).value_mut();
    let now = (self.now)();
    let dt = now.saturating_duration_since(b.last_refill).as_secs_f32();
    b.tokens = (b.tokens + dt * b.refill_per_sec).min(b.capacity as f32);
    b.last_refill = now;
    if b.tokens >= cost {
      b.tokens -= cost;
      Decision::Allow {
        limit: b.capacity,
        remaining: b.tokens,
        reset_epoch: calc_reset_epoch(b),
      }
    } else {
      let need = cost - b.tokens;
      let retry = (need / b.refill_per_sec).ceil() as u64;
      Decision::Throttle {
        limit: b.capacity,
        remaining: b.tokens.max(0.0),
        reset_epoch: (now + Duration::from_secs(retry)).duration_since(UNIX_EPOCH).as_secs(),
        retry_after_secs: retry,
      }
    }
  }
}
```

No `IntoResponse`, preencher headers de rate limit em **todas** as respostas.

* * *

7) Testes
---------

### 7.1 Unit

*   **burst\_accepts\_until\_capacity**: consome `capacity` requisi√ß√µes, a `capacity+1` ‚Üí 429 com `Retry-After > 0`.
*   **refill\_progressively**: avan√ßa rel√≥gio; `Remaining` sobe e volta a aceitar.
*   **cost\_by\_method**: `POST` consome mais tokens que `GET`.
*   **override\_resolution\_order**: `client_id` override vence `app,tenant`; fallback para global.
*   **reset\_epoch\_monotonic**: `X-RateLimit-Reset` nunca retrocede dentro do ciclo.

### 7.2 Integra√ß√£o

*   **isolation\_between\_tenants**: `myapp/acme` e `myapp/contoso` n√£o afetam os buckets um do outro (mesmo client\_id).
*   **legacy\_scope\_defaults**: `/v1/execute` cai em `default:default`.
*   **replay\_does\_not\_debit**: duas chamadas com mesma `Idempotency-Key` ‚Üí 2¬™ √© `Replay`, `Remaining` n√£o diminui.
*   **preflight\_exposes\_headers**: `OPTIONS` retorna cabe√ßalhos CORS corretos com `access-control-expose-headers` incluindo `X-RateLimit-*`.

* * *

8) Observabilidade
------------------

M√©tricas Prometheus:

*   `gate_ratelimit_decisions_total{outcome="allow|throttle"}`
*   `gate_ratelimit_bucket_tokens{scope,client_id}` (gauge amostrado periodicamente ‚Äî opcional)
*   `gate_ratelimit_retry_after_seconds` (histograma)

Tracing:

*   `rate.check` (tags: scope, client\_id, route\_id, outcome, remaining)

* * *

9) Falhas e hardening
---------------------

*   **Clock skew**: usar `Instant` local; `Reset` usa `SystemTime` apenas para o header.
*   **Ataques de cardinalidade**: limitar n√∫mero de chaves vivas (`DashMap` + LRU por √∫ltimo acesso).
*   **Cold start burst**: aquecer buckets com `tokens=capacity` (padr√£o), ou metade em tenants ruidosos.
*   **Token precision**: `f32` suficiente; se quiser precis√£o exata, usar `u64` (microtokens) e aritm√©tica inteira.

* * *

10) Contrato de erros (AppError)
--------------------------------

Mesmo para 429, responder JSON padronizado:

```json
{
  "error": { "code": "rate_limited", "message": "Too Many Requests" },
  "request_id": "r-abc123",
  "retry_after": 2
}
```

E cabe√ßalhos `X-RateLimit-*` + `Retry-After`.

* * *

11) Compatibilidade com CLI/UI
------------------------------

*   CLI `ublx` pode imprimir `X-RateLimit-*` quando `--verbose` (ajuda a entender recuos).
*   UI: mostrar ‚Äúcooldown‚Äù com base em `Retry-After` e `Remaining/Limit`.

* * *

12) Crit√©rios de aceite
-----------------------

*   ‚úÖ Limita√ß√£o **por escopo** (app, tenant, client\_id), isolada entre tenants.
*   ‚úÖ `X-RateLimit-*` + `Retry-After` presentes em todas as respostas relevantes e **expostos** no CORS.
*   ‚úÖ Comportamento em **burst** previs√≠vel, **refill** suave, e integra√ß√£o com **Idempotency** (replays n√£o debitam).
*   ‚úÖ Suite de testes unit + integra√ß√£o cobrindo burst, refill e isolamento.

Se quiser, preparo j√° o patch do middleware (com `DashMap`, `Instant`, config por env e exposi√ß√£o de headers) e a bateria de testes de integra√ß√£o usando o mini-server Axum de testes.

## Prompt:
7!

## Response:
Aqui vai o **Cap√≠tulo 7/12 ‚Äî Receipt API √† prova de ‚Äúb3:‚Äù**. Foco: rotas que aceitam `b3:...` sem atrito, respostas **sempre** em JSON padronizado e casos de erro previs√≠veis.

7/12 ¬∑ Receipt API √† prova de `b3:‚Ä¶`
====================================

1) Objetivos
------------

*   `GET /v1/receipt/{cid}` e `GET /a/{app}/t/{tenant}/v1/receipt/{cid}` aceitam **qualquer CID v√°lido**, inclusive com **`:`** (`b3:‚Ä¶`), **sem exigir** `Content-Type`.
*   Respostas de erro **uniformes** via `AppError` (`code`, `message`, `request_id`, `retry_after?`) ‚Äî inclusive 400/404/429/5xx.
*   Cobertura de testes: `b3:` feliz, **CID inexistente**, **CID malformado**, e comportamento em **legacy vs. scoped**.

* * *

2) Rotas & extra√ß√£o do par√¢metro
--------------------------------

**Axum 0.7** usa chaves `{param}`. Troque `:cid` ‚Üí `{cid}` e garanta rotas **scoped** e **legacy**:

```rust
// scoped (preferencial)
.route("/a/{app}/t/{tenant}/v1/receipt/{cid}", get(api::get_receipt))
// legacy (fallback p/ default:default)
.route("/v1/receipt/{cid}", get(api::get_receipt_legacy))
```

> Nota: `:` dentro do **segmento** de path n√£o quebra o matcher; o problema cl√°ssico era rota n√£o bater por sintaxe antiga. Com `{cid}` isso desaparece.

* * *

3) Guard de Content-Type (GET n√£o exige)
----------------------------------------

Se voc√™ tem um guard global ‚ÄúJSON only‚Äù, **pule GET/HEAD**:

```rust
fn require_json_on_write(req: &Request<Body>) -> bool {
    match *req.method() {
        Method::POST | Method::PUT | Method::PATCH => true,
        _ => false, // GET/HEAD/DELETE n√£o exigem Content-Type
    }
}
```

Aplique o guard s√≥ quando `true`. Isso elimina o 400 ‚ÄúBad Request (Content-Type)‚Äù em GET.

* * *

4) Parsing e valida√ß√£o do CID
-----------------------------

Trate **duas entradas**:

*   `cid` ‚Äúcru‚Äù do path (pode vir percent-encoded)
*   `cid` com **prefixo amig√°vel** opcional, ex.: `cid:b3:‚Ä¶`

```rust
fn normalize_cid(raw: &str) -> Result<String, AppError> {
    // 1) decode %3A se vier percent-encoded
    let decoded = percent_encoding::percent_decode_str(raw).decode_utf8_lossy();
    let s = decoded.as_ref();

    // 2) strip "cid:" se presente
    let s = s.strip_prefix("cid:").unwrap_or(s);

    // 3) valida√ß√£o m√≠nima: deve come√ßar com "b3:" e ter tamanho esperado
    if !s.starts_with("b3:") { 
        return Err(AppError::bad_request("invalid_cid_prefix", "CID must start with b3:"));
    }
    if s.len() != 2 + 1 + 64 { // "b3:" + 64 hex
        return Err(AppError::bad_request("invalid_cid_length", "CID length mismatch"));
    }

    // 4) (opcional) validar charset/hex
    if !s[3..].chars().all(|c| c.is_ascii_hexdigit()) {
        return Err(AppError::bad_request("invalid_cid_chars", "CID contains non-hex chars"));
    }

    Ok(s.to_string())
}
```

> Se voc√™ j√° tem um **tipo** `Cid` na crate de core, mova essa l√≥gica para l√° e exponha `Cid::parse(&str)` para reutiliza√ß√£o (gate, CLI, testes).

* * *

5) Handler unificado com `AppError` (JSON sempre)
-------------------------------------------------

### Esquema de sucesso (200)

```json
{
  "cid": "b3:‚Ä¶",
  "phase": "WF",
  "decision": "PASS",
  "jws": { "alg":"Ed25519","kid":"did:key:‚Ä¶","payload":"‚Ä¶" },
  "links": { "self": "/‚Ä¶/receipt/b3:‚Ä¶", "verify": "/‚Ä¶/verify/b3:‚Ä¶" },
  "runtime": { "did":"did:key:‚Ä¶", "sha256":"‚Ä¶" }
}
```

### Esquema de erro (padr√£o)

```json
{
  "error": { "code": "not_found", "message": "Receipt not found" },
  "request_id": "r-abc123",
  "retry_after": 0
}
```

### Handler (resumo)

```rust
pub async fn get_receipt(
    Extension(state): Extension<AppState>,
    scope: Scope,                    // /a/{app}/t/{tenant}/...
    Path(cid_raw): Path<String>,
) -> Result<Json<Value>, AppError> {
    let cid = normalize_cid(&cid_raw)?;

    // 1) look-up no storage 'scoped' (app:tenant:cid)
    if let Some(doc) = state.receipts.get(&scope.scoped_cid(&cid)) {
        return Ok(Json(scrub_for_public(doc)));
    }

    // 2) fallback legacy (compat)
    if let Some(doc) = state.receipts.get(&cid) {
        return Ok(Json(scrub_for_public(doc)));
    }

    Err(AppError::not_found("not_found", "Receipt not found"))
}

pub async fn get_receipt_legacy(
    Extension(state): Extension<AppState>,
    Path(cid_raw): Path<String>,
) -> Result<Json<Value>, AppError> {
    // projeta para scope default:default
    get_receipt(Extension(state), Scope::default(), Path(cid_raw)).await
}
```

> `scrub_for_public` remove metadados internos (`__tenant_id`, etc.) e garante **determinismo** de campos/ordem (√∫til para diffs e impress√£o).

* * *

6) Links can√¥nicos e Self-Discovery
-----------------------------------

Monte `links.self` respeitando **escopo**:

*   Scoped: `"/a/{app}/t/{tenant}/v1/receipt/{cid}"`
*   Legacy: `"/v1/receipt/{cid}"`

Para a UI/CLI, ofere√ßa **ambos** se dispon√≠vel:

```json
"links": { "self": "/a/app/t/tenant/v1/receipt/b3:‚Ä¶", "self_legacy": "/v1/receipt/b3:‚Ä¶" }
```

* * *

7) Cabe√ßalhos & CORS
--------------------

*   **N√£o exigir** `Content-Type` em GET.
*   CORS: manter `expose-headers` j√° ampliados (rate limit, retry-after).
*   Cache-control (opcional): accepted **public, immutable** caso o receipt seja imut√°vel e p√∫blico no seu dom√≠nio:
    ```
    Cache-Control: public, max-age=31536000, immutable
    ```

* * *

8) Testes (unit + integra√ß√£o)
-----------------------------

### Unit ‚Äî `normalize_cid`

*   `ok_b3_plain`: `"b3:‚Ä¶"` v√°lido ‚Üí Ok
*   `ok_b3_with_prefix`: `"cid:b3:‚Ä¶"` ‚Üí Ok
*   `ok_b3_percent`: `"b3%3A‚Ä¶"` ‚Üí Ok
*   `bad_prefix`: `"z3:‚Ä¶"` ‚Üí `invalid_cid_prefix`
*   `bad_len`: `"b3:short"` ‚Üí `invalid_cid_length`
*   `bad_chars`: `"b3:‚Ä¶g‚Ä¶"` ‚Üí `invalid_cid_chars`

### Integra√ß√£o ‚Äî handler

1.  **Scoped b3**  
    `GET /a/x/t/y/v1/receipt/b3:‚Ä¶` ‚Üí 200 JSON, `links.self` scoped, body sem campos internos.
2.  **Legacy b3**  
    `GET /v1/receipt/b3:‚Ä¶` ‚Üí 200 JSON, `links.self` legacy.
3.  **Inexistente**  
    `GET /v1/receipt/b3:FFFFFFFF‚Ä¶` ‚Üí 404 JSON (`code=not_found`), **sem** exigir Content-Type.
4.  **Malformado**  
    `GET /v1/receipt/b3:Z‚Ä¶` ‚Üí 400 JSON (`code=invalid_cid_chars`).
5.  **Percent-encoded**  
    `GET /v1/receipt/b3%3Aabcd‚Ä¶` ‚Üí 200 JSON (se existe).
6.  **CORS + GET**  
    `OPTIONS` preflight para `/v1/receipt/b3:‚Ä¶` ‚Üí 204/200 com `Access-Control-Allow-*` correto; `GET` real n√£o retorna 400 por Content-Type ausente.
7.  **Isolamento**  
    Receipt existe em `x:y`, mas **n√£o** em `x:z` ‚Üí `404` no escopo errado.
8.  **AppError shape**  
    Para 400/404/5xx, assert JSON com `error.code`, `message`, `request_id` e (se 429) `retry_after`.

> Dica: injete `Scope` e um `AppState` de teste com mapa em mem√≥ria; use o **mesmo** `AppError` do runtime (via `IntoResponse`) para padronizar.

* * *

9) Seguran√ßa & UX
-----------------

*   **Timing**: mensagens de erro padronizadas evitam leak de exist√™ncia (‚Äúuser enumeration‚Äù an√°logo).
*   **Log**: trace com `request_id` inclu√≠do na resposta; isso fecha o loop de suporte.
*   **CLI/UI**: sempre aceitar `cid:b3:‚Ä¶` e `b3:‚Ä¶`; CLI pode imprimir a URL can√¥nica e j√° abrir a UI.

* * *

10) Compat & Migra√ß√£o
---------------------

*   Manter `GET /v1/receipt/{cid}` por um ciclo LTS como **alias** de `default:default`.
*   Emite `Deprecation` header (opcional) com dica do caminho scoped:
    ```
    Deprecation: true
    Link: </a/{app}/t/{tenant}/v1/receipt/{cid}>; rel="alternate"
    ```

* * *

11) Crit√©rios de aceite
-----------------------

*   ‚úÖ `GET` aceita `b3:` (cru e percent-encoded), **sem** exigir `Content-Type`.
*   ‚úÖ Erros 400/404/429/5xx em **JSON** (`AppError`), com `request_id`.
*   ‚úÖ Testes cobrindo feliz, inexistente, malformado, legacy e scoped.
*   ‚úÖ Links can√¥nicos corretos por escopo, sem vazar metadados internos.

* * *

12) Pr√≥ximos passos (liga√ß√£o com Cap. 8)
----------------------------------------

*   ‚ÄúBattle Script‚Äù deve:
    *   Criar receipt ‚Üí validar `GET` em **scoped** e **legacy**.
    *   Exercitar `b3%3A‚Ä¶` (encoded) e inexistente.
    *   Checar **CORS** e **RateLimit headers** expostos em GET (quando habilitados).
    *   Validar **AppError** shape uniformizado.

Se quiser, te mando um patch pronto contendo: `normalize_cid` no core, rotas `{cid}`, guard condicional de Content-Type, `AppError` com `IntoResponse`, testes unit/integration e fixtures m√≠nimos de store em mem√≥ria.

## Prompt:
8:

8) ‚ÄúBattle Script‚Äù end-to-end
Rode gate com auth ligada; crie sempre user ‚Üí app ‚Üí tenant via CLI p√∫blica/admin (sem atalhos). Cen√°rios: determinismo com ghost:true, CORS em tr√™s camadas, audit report, /receipts e /audit antes/depois, e isolamento entre dois tenants.

9) CLI P√∫blica como Fonte da Verdade
Fa√ßa a UI e testes integrais consumirem exatamente o que a CLI consome (mesmo contrato). Se houver descompasso CLI admin ‚Üî API, abra issue ‚Äúalignment‚Äù com: contrato esperado, contrato atual, e teste reprodutor.

10) EventBus (Iggy) Plug√°vel
Ap√≥s persistir (ledger), publique ReceiptEvent { scope, phase, cid, parent, decision, ts }. Trait EventBus com impl IggyEventBus. Tests: at-least-once (reprocessamento idempotente), parti√ß√£o por app:tenant.

11) Observabilidade Base
Tracing spans (gate.request, policy.decide, runtime.exec, ledger.put, event.publish), Prometheus (pass/deny/retry; hist de exec), e dashboard m√≠nimo. Testes de m√©tricas: exporta e conta passa.

12) Receipt UI (Canvas) ‚Üí Integra√ß√£o
A p√°gina do canvas j√° est√° est√°vel (corrigido o ) no copy). Pr√≥ximos passos:
	‚Ä¢	Ligar ?cid=... ‚Üí fetch real, com ‚ÄúDemo Mode‚Äù quando sem cid.
	‚Ä¢	‚ÄúVerify‚Äù abrir guia com instru√ß√µes (CLI ublx verify + libs).
	‚Ä¢	Testes leves j√° existem; adicione: PASS/RETRY/DENY altera progress, popovers acess√≠veis (aria), ‚ÄúCopy All‚Äù inclui links.self, e modo impress√£o exibe faixa de autenticidade.

## Response:
Aqui vai o **Cap√≠tulo 8/12 ‚Äî ‚ÄúBattle Script‚Äù end-to-end**. √â um script √∫nico, autodocumentado e ‚Äúfail-fast‚Äù, que cobre: **auth ON**, cria√ß√£o **user‚Üíapp‚Üítenant** via CLIs (sem atalhos), **determinismo com `ghost:true`**, **CORS** (global ‚Üí app ‚Üí tenant), **auditoria** antes/depois, **/receipts** e **/audit**, e **isolamento** entre dois tenants. Inclui tamb√©m checks de **rate-limit headers**, **preflight**, e retornos JSON padronizados.

> Pr√©-requisitos:
> 
> *   `ubl_gate` j√° compilado (`cargo build --release -p ubl_gate`)
> *   CLIs: `ublx` (p√∫blica) e `ublx-admin` (admin) no `PATH`
> *   `jq`, `curl`
> *   Gate escutando em `http://localhost:3000` com auth **ligada** (tokens dev habilitados)
>     

* * *

### `battle.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

# ========== CONFIG ==========
GATE="${GATE:-http://localhost:3000}"
AUTH_GOOD="${AUTH_GOOD:-ubl-dev-token-001}"   # token v√°lido mapeado para default tenant/app, ou via admin
AUTH_BAD="${AUTH_BAD:-invalid-token}"
UA="battle/1.0"

# Usu√°rio/App/Tenant can√¥nicos para os cen√°rios
USER_EMAIL_1="danvoulez@example.com"
APP_1="dan-projects"
TENANT_1="profissional"

USER_EMAIL_2="guest@example.com"
APP_2="guest-app"
TENANT_2="sandbox"

# CORS origins para os 3 n√≠veis
ORIGIN_GLOBAL="https://global.example"
ORIGIN_APP_1="https://app1.example"
ORIGIN_TENANT_1="https://prof.example"

# Helpers
jqget(){ jq -r "$1"; }
hdr(){ grep -i "^$1:" | sed -E "s/^$1:[[:space:]]*//I"; }
log(){ printf "\n\033[1m‚ñ∂ %s\033[0m\n" "$*"; }

curlj(){
  # curl JSON with bearer and UA, capture code+body+headers
  local method="$1"; shift
  local url="$1"; shift
  curl -sS -X "$method" "$url" \
    -H "User-Agent: $UA" \
    -H "Authorization: Bearer $AUTH_GOOD" \
    -H "Content-Type: application/json" "$@"
}

curll(){
  # raw curl (used for preflight / header checks)
  curl -sS -D - "$@" -o /tmp/_body.txt
}

require_json_error(){
  local code expected_code
  code="$1"; expected_code="$2"
  [[ "$code" == "$expected_code" ]] || { echo "Expected HTTP $expected_code, got $code"; exit 1; }
  jq -e '.error.code and .error.message and .request_id' /tmp/_body.txt > /dev/null
}

# ========== 0) GATE HEALTH + AUTH BASELINE ==========
log "0) Health e Auth baseline"
curl -sS "$GATE/healthz" | jq -e '.ok == true' >/dev/null
echo "‚Ä¢ /healthz ok"

# auth ON ‚Üí sem token d√° 401 JSON (AppError shape)
log "Auth checks (no token e token inv√°lido)"
curll -X GET "$GATE/v1/receipts"
HTTP=$(grep -Eo "^HTTP/[^ ]+ [0-9]{3}" /tmp/_body.txt | tail -1 | awk '{print $2}')
require_json_error "$HTTP" "401" && echo "‚Ä¢ 401 no token (JSON AppError)"

curll -X GET "$GATE/v1/receipts" -H "Authorization: Bearer $AUTH_BAD"
HTTP=$(grep -Eo "^HTTP/[^ ]+ [0-9]{3}" /tmp/_body.txt | tail -1 | awk '{print $2}')
require_json_error "$HTTP" "401" && echo "‚Ä¢ 401 bad token (JSON AppError)"

# ========== 1) USER ‚Üí APP ‚Üí TENANT (CLIs) ==========
log "1) Criar user ‚Üí app ‚Üí tenant (sem atalhos)"

# 1.1 Usuario
UBLX_USER_ID=$(ublx user create --email "$USER_EMAIL_1" | jqget '.user_id')
echo "‚Ä¢ user1: $UBLX_USER_ID"

# 1.2 App (admin) ‚Äì app deve existir por um admin (sem ‚Äúatalho m√°gico‚Äù no gate)
APP1_ID=$(ublx-admin app create --name "$APP_1" --owner "$UBLX_USER_ID" | jqget '.app_id')
echo "‚Ä¢ app1: $APP1_ID"

# 1.3 Tenant (admin) ‚Äì idem
TENANT1_ID=$(ublx-admin tenant create --app "$APP1_ID" --slug "$TENANT_1" | jqget '.tenant_id')
echo "‚Ä¢ tenant1: $TENANT1_ID"

# 1.4 Convidar usu√°rio para o app/tenant (por email; fluxo ‚Äúaceite r√°pido‚Äù se j√° logado)
INV_CODE=$(ublx-admin invite create --app "$APP1_ID" --tenant "$TENANT1_ID" --email "$USER_EMAIL_1" | jqget '.invite_code')
echo "‚Ä¢ invite code: $INV_CODE"
ublx invite accept --code "$INV_CODE" 1>/dev/null && echo "‚Ä¢ convite aceito"

# ========== 2) RECEIPT BEFORE/AFTER + DETERMINISMO ==========
log "2) /receipts e determinismo (ghost:true evita 409 de idempot√™ncia de neg√≥cio)"

echo "{}" > /tmp/payload.json # seu payload can√¥nico de teste pode ser maior

# Antes: n√£o deve haver receipts
curlj GET "$GATE/a/$APP_1/t/$TENANT_1/v1/receipts" | jq -e 'length == 0 or (type=="object")' >/dev/null
echo "‚Ä¢ /receipts vazio (ou mapa vazio)"

# Execu√ß√£o determin√≠stica: mesmo manifesto/policy + ghost:true gera m√∫ltiplos WA/WF mas com SAME CIDs
MANIFEST="$(jq -n '{
  pipeline:"test",
  in_grammar:{inputs:{__prev_output__:""},mappings:[],output_from:"__prev_output__"},
  out_grammar:{inputs:{__prev_output__:""},mappings:[],output_from:"__prev_output__"},
  policy:{allow:true}
}')"

for i in 1 2 3; do
  TIP=$(curlj POST "$GATE/a/$APP_1/t/$TENANT_1/v1/execute" \
    --data "$(jq -n --argjson mf "$MANIFEST" '{manifest:$mf, vars:{__prev_output__:"battle"}, ghost:true}')" \
    | jqget '.tip_cid')
  echo "‚Ä¢ run#$i tip=$TIP"
  [[ "$TIP" =~ ^b3: ]] || { echo "CID inv√°lido"; exit 1; }
  TIPS+=" $TIP"
done

# assert todos iguais
set -- $TIPS
[[ "$1" == "$2" && "$2" == "$3" ]] || { echo "Determinismo falhou: $TIPS"; exit 1; }
TIP="$1"
echo "‚Ä¢ determinismo OK (mesmo tip_cid)"

# Depois: receipts presentes
curlj GET "$GATE/a/$APP_1/t/$TENANT_1/v1/receipts" | jq -e "has(\"$TIP\")" >/dev/null
echo "‚Ä¢ /receipts cont√©m $TIP"

# Receipt API ‚Äú√† prova de b3:‚Äù (sem exigir Content-Type)
RCPT=$(curl -sS -H "Authorization: Bearer $AUTH_GOOD" "$GATE/a/$APP_1/t/$TENANT_1/v1/receipt/$TIP")
echo "$RCPT" | jq -e ".cid == \"$TIP\"" >/dev/null && echo "‚Ä¢ /receipt/{b3:...} ok"

# ========== 3) AUDIT BEFORE/AFTER ==========
log "3) /audit antes/depois"

# Audit ap√≥s execu√ß√µes
curlj GET "$GATE/a/$APP_1/t/$TENANT_1/v1/audit" | jq -e '.summary and .breakdown' >/dev/null
echo "‚Ä¢ audit (scoped) ok"

# ========== 4) CORS: global ‚Üí app ‚Üí tenant ==========
log "4) CORS (global, app, tenant) + preflight"

# Configure via env/CLI admin (exemplo conceitual; adapte ao seu mecanismo de config)
ublx-admin cors set-global --origins "$ORIGIN_GLOBAL" >/dev/null
ublx-admin cors set-app    --app "$APP1_ID"    --origins "$ORIGIN_APP_1" >/dev/null
ublx-admin cors set-tenant --tenant "$TENANT1_ID" --origins "$ORIGIN_TENANT_1" >/dev/null
echo "‚Ä¢ CORS configs aplicadas"

preflight(){
  local ORG="$1"
  curll -X OPTIONS "$GATE/a/$APP_1/t/$TENANT_1/v1/receipt/$TIP" \
    -H "Origin: $ORG" \
    -H "Access-Control-Request-Method: GET" \
    -H "Access-Control-Request-Headers: Authorization"
  HTTP=$(grep -Eo "^HTTP/[^ ]+ [0-9]{3}" /tmp/_body.txt | tail -1 | awk '{print $2}')
  [[ "$HTTP" =~ ^(200|204)$ ]] || { echo "Preflight falhou ($ORG): $HTTP"; exit 1; }
  ALLOW=$(hdr "Access-Control-Allow-Origin")
  echo "‚Ä¢ Preflight $ORG ‚Üí Allow-Origin=$ALLOW"
}

# Tenant vence sobre app, que vence sobre global
preflight "$ORIGIN_GLOBAL"
preflight "$ORIGIN_APP_1"
preflight "$ORIGIN_TENANT_1"

# GET real com CORS + RateLimit headers expostos
curll -H "Origin: $ORIGIN_TENANT_1" \
     -H "Authorization: Bearer $AUTH_GOOD" \
     "$GATE/a/$APP_1/t/$TENANT_1/v1/receipt/$TIP"
ALLOW=$(hdr "Access-Control-Allow-Origin"); echo "‚Ä¢ GET CORS allow=$ALLOW"
RLIM=$(hdr "x-ratelimit-limit"); RREM=$(hdr "x-ratelimit-remaining")
echo "‚Ä¢ RateLimit headers: limit=$RLIM remaining=$RREM"

# ========== 5) ISOLAMENTO ENTRE TENANTS ==========
log "5) Isolamento de dados (tenant B n√£o enxerga receipt de A)"

# Cria user/app/tenant 2
USER2_ID=$(ublx user create --email "$USER_EMAIL_2" | jqget '.user_id')
APP2_ID=$(ublx-admin app create --name "$APP_2" --owner "$USER2_ID" | jqget '.app_id')
TENANT2_ID=$(ublx-admin tenant create --app "$APP2_ID" --slug "$TENANT_2" | jqget '.tenant_id')
INV2=$(ublx-admin invite create --app "$APP2_ID" --tenant "$TENANT2_ID" --email "$USER_EMAIL_2" | jqget '.invite_code')
ublx invite accept --code "$INV2" 1>/dev/null

# Tentativa de ler receipt do tenant1 a partir do tenant2 ‚Üí 404 JSON
curll -H "Authorization: Bearer $AUTH_GOOD" \
      "$GATE/a/$APP_2/t/$TENANT_2/v1/receipt/$TIP"
HTTP=$(grep -Eo "^HTTP/[^ ]+ [0-9]{3}" /tmp/_body.txt | tail -1 | awk '{print $2}')
require_json_error "$HTTP" "404" && echo "‚Ä¢ isolamento ok (404 no escopo errado)"

# ========== 6) RATE LIMIT: burst/refill e isolamento ==========
log "6) Rate limit: burst/refill + isolamento (por app,tenant,client_id)"

# 3 hits r√°pidos ‚Üí remaining deve decrescer
for i in 1 2 3; do
  curll -H "Authorization: Bearer $AUTH_GOOD" "$GATE/a/$APP_1/t/$TENANT_1/v1/receipt/$TIP"
  echo "‚Ä¢ hit#$i remaining=$(hdr x-ratelimit-remaining)"
done

# Tenant2 n√£o ‚Äúconsome‚Äù o bucket do tenant1
curll -H "Authorization: Bearer $AUTH_GOOD" "$GATE/a/$APP_2/t/$TENANT_2/v1/receipts"
echo "‚Ä¢ tenant2 remaining=$(hdr x-ratelimit-remaining) (bucket distinto)"

# (Opcional) For√ßar 429 e validar AppError+retry_after
# Repetir chamadas at√© retornar 429, ent√£o:
# require_json_error "$HTTP" "429" && echo "‚Ä¢ 429 shape ok (retry_after=$(hdr Retry-After))"

# ========== 7) RECEIPTS & AUDIT (LEGACY vs SCOPED) ==========
log "7) Legacy vs Scoped"

# Scoped (j√° validado). Agora legacy como alias default:default (se habilitado)
curll -H "Authorization: Bearer $AUTH_GOOD" "$GATE/v1/receipt/$TIP"
HTTP=$(grep -Eo "^HTTP/[^ ]+ [0-9]{3}" /tmp/_body.txt | tail -1 | awk '{print $2}')
if [[ "$HTTP" == "200" ]]; then
  echo "‚Ä¢ legacy receipt compat ativa"
else
  echo "‚Ä¢ legacy receipt indispon√≠vel (ok se desativado por pol√≠tica de migra√ß√£o)"
fi

echo -e "\n‚úÖ BATTLE: passou por auth, cria√ß√£o can√¥nica, determinismo, CORS 3 camadas, audit, isolamento, rate-limit e Receipt API b3.\n"
```

* * *

### Notas de design e verifica√ß√£o

*   **Determinismo**: o script usa `ghost:true` para evitar colis√µes de idempot√™ncia de neg√≥cio; o **CID do `tip`** deve se repetir nas 3 execu√ß√µes.
*   **CORS**: testamos **preflight OPTIONS** e **GET real** com `Origin` variando; o **tenant** deve sobrescrever o **app**, que sobrescreve o **global**.
*   **Receipt API**: o `GET /receipt/{b3:...}` n√£o envia `Content-Type`, garantindo que o guard s√≥ exige JSON para **writes**.
*   **AppError shape**: erros 401/404 (e 429 se voc√™ habilitar a parte comentada) s√£o validados por JSON com `error.code`, `message`, `request_id`, e `Retry-After` quando aplic√°vel.
*   **Isolamento**: criamos um **segundo tenant** e confirmamos que **n√£o** √© poss√≠vel ler o receipt do primeiro (404 scoped).
*   **Rate-limit**: confirmamos **counters por escopo** `(app,tenant,client_id)` e que **tenants** n√£o compartilham bucket.

* * *

### Como rodar

```bash
chmod +x battle.sh
GATE=http://localhost:3000 AUTH_GOOD=ubl-dev-token-001 ./battle.sh
```

Se quiser simular exaust√£o de **rate-limit**, reduza o limite no gate (ou aumente os hits) e descomente o bloco de 429.

* * *

Se quiser, eu adapto o script para **mk/Justfile** com alvos (`just battle`), ou que **suba o gate** automaticamente (com `nohup` + health-wait) e fa√ßa o teardown no final.

## Prompt:
9

## Response:
Cap√≠tulo 9/12 ‚Äî CLI P√∫blica como Fonte da Verdade
-------------------------------------------------

**Tese:** tudo que a UI e os testes de integra√ß√£o fazem deve ser **id√™ntico** ao que um usu√°rio faria com a **CLI p√∫blica (`ublx`)**. A CLI vira o **contrato operacional** do ecossistema. A CLI admin (`ublx-admin`) s√≥ cobre trilhas administrativas; nada ‚Äúexclusivo‚Äù deve existir nela que n√£o tenha reflexo de consumo na p√∫blica.

* * *

### 9.1 Contrato √önico: ‚Äúo que a CLI fala √© lei‚Äù

1.  **Spec gerado da CLI ‚Üí API**
    *   A CLI p√∫blica **n√£o** cont√©m l√≥gica de neg√≥cio. Ela √© um **thin client** sobre um √∫nico contrato OpenAPI (ou similar) versionado.
*   Gere `openapi.json` a partir do **c√≥digo do gate** (derivado dos handlers), **n√£o** da CLI.
*   A CLI consome esse spec para gerar:
    *   Tipos (serde) e validadores.
    *   Tabela de comandos/flags ‚Üí endpoints/m√©todos/headers.
        2.  **UI consome o mesmo spec/SDK**
    *   A UI usa o **mesmo cliente** que a CLI (mesma lib gerada/SDK).
*   Se a CLI enxerga um campo novo, a UI enxerga tamb√©m ‚Äî sem forks.
    3.  **Sem atalhos fora da CLI**
    *   Fluxos de produto (onboarding, emiss√£o de recibo, auditoria) **existem 1:1** na CLI.
*   Qualquer opera√ß√£o ‚Äús√≥ existe na UI‚Äù ou ‚Äús√≥ via API admin‚Äù √© **cheiro de desalinhamento**.

* * *

### 9.2 Estrutura da CLI (p√∫blica)

```
ublx
‚îú‚îÄ auth
‚îÇ  ‚îú‚îÄ login                     # troca por token; salva profile local (~/.ublx/config)
‚îÇ  ‚îî‚îÄ status                    # mostra tenant/app corrente, expira√ß√£o, scopes
‚îú‚îÄ scope
‚îÇ  ‚îú‚îÄ select --app A --tenant T # fixa app/tenant p/ sess√£o/profile
‚îÇ  ‚îî‚îÄ show
‚îú‚îÄ user
‚îÇ  ‚îú‚îÄ create --email E          # inicia conta (com flow de confirma√ß√£o, se on)
‚îÇ  ‚îî‚îÄ invite-accept --code C    # aceite ‚Äúsem fric√ß√£o‚Äù se j√° autenticado
‚îú‚îÄ app
‚îÇ  ‚îî‚îÄ join --id APP_ID | --slug # entra em app existente (via convite ou pol√≠tica aberta)
‚îú‚îÄ tenant
‚îÇ  ‚îî‚îÄ join --id TEN_ID | --slug # idem
‚îú‚îÄ execute
‚îÇ  ‚îú‚îÄ run --manifest M.json [--vars V.json] [--ghost]
‚îÇ  ‚îî‚îÄ verify --cid b3:...       # verifica receipt (hash + JWS)
‚îú‚îÄ receipts
‚îÇ  ‚îú‚îÄ list                      # lista (scoped)
‚îÇ  ‚îî‚îÄ get  --cid b3:...         # retorna (scoped)
‚îî‚îÄ audit
   ‚îî‚îÄ report [--format json|md]  # resumo + breakdown + timeline (scoped)
```

*   **Padr√£o de flags**: tudo que √© ‚Äúambiente‚Äù (gate URL, token, app/tenant) pode vir via env `UBL_*` e √© sobreposto por flags.
*   **Sa√≠das est√°veis**: use `--json` para imprimir **somente** JSON; sem logs misturados.

* * *

### 9.3 Golden Tests de Contrato (CLI ‚áÑ API ‚áÑ UI)

Crie uma su√≠te de ‚Äúgoldens‚Äù (Instant√¢neos) versionada:

*   **Comandos** ‚Üí **requests**: cada subcomando da CLI tem pares `stdin ‚Üí stdout.json` e `stdout.md` (quando aplic√°vel).
*   **Round-trip**: UI e testes e2e devem **reutilizar** as mesmas fun√ß√µes de cliente (SDK) ‚Äî os mesmos mocks/in-memory tamb√©m.
*   **Invariantes** (exemplos):
    *   `execute run` com o mesmo manifest + `--ghost` gera **mesmo** `tip_cid`.
    *   `receipts get` nunca exige `Content-Type`.
    *   Erros seguem `AppError` `{ code, message, request_id, retry_after? }`.
    *   Cabe√ßalhos \*_X-RateLimit-_ \*\* s√£o expostos quando CORS v√°lido.

Automatize com um runner:

```bash
# pseudo-make
golden:
  # 1) levanta gate com profile ‚Äútest‚Äù
  # 2) roda ublx ... --json > .golden/...
  # 3) compara com fixtures (ou atualiza com flag --update)
```

* * *

### 9.4 Boundary Tests de Compatibilidade

Teste o ‚Äútri√¢ngulo‚Äù **CLI p√∫blica ‚Üî API p√∫blica ‚Üî UI**:

1.  **Smoke** (por commit):
    *   `ublx auth status` ‚áí 200 / shape ok
*   `ublx execute run --ghost` ‚áí `tip_cid` b3:\*
*   `ublx receipts get --cid ...` ‚áí JSON receipt v√°lido
    2.  **Compat menor (SemVer)**:
    *   Adi√ß√µes de campos **n√£o** quebram CLI (`serde(default)`).
*   Flags novas t√™m **default** compat√≠vel.
    3.  **Compat maior**:
    *   Planeje ‚Äújanela‚Äù de deprecia√ß√£o: CLI vN continua funcional enquanto API mant√©m **alias** (ex.: rota legacy `/v1/...` apontando p/ `/a/{app}/t/{tenant}/v1/...`).

* * *

### 9.5 Playbook de Alinhamento (quando der drift)

Quando perceber descompasso **CLI admin ‚Üî API admin** ou **CLI p√∫blica ‚Üî API p√∫blica**:

1.  **Abra issue `alignment:` com o template:**

```
alignment: <√°rea>
contrato_esperado:
  - comando: ublx <path> [flags]
  - request: METHOD PATH (headers)
  - response: <json schema curto>
contrato_atual:
  - ...
impacto:
  - testes que falharam: <links>
  - UIs afetadas: <quais>
proposta:
  - fix server|fix cli|adicionar alias|migra√ß√£o em 2 etapas
teste_reprodutor:
  - script curto (curl/ublx) + asserts
```

2.  **Decis√£o em 24‚Äì48h**:
    *   Escolha **1**: **corrigir servidor** para bater no esperado (prefer√≠vel se √© bug de regress√£o).
*   Escolha **2**: **corrigir CLI** e publicar **release** + **changelog** + **alias** tempor√°rio no server.
    3.  **Execu√ß√£o**:
    *   Adicione **teste de n√£o regress√£o** na su√≠te golden e e2e.
*   Se houver mudan√ßa de rota/campos: mantenha **alias** por 1‚Äì2 vers√µes e logue deprecia√ß√£o.

* * *

### 9.6 Observabilidade de Contrato

*   Exponha m√©trica: `cli_contract_mismatch_total` (label `area=auth|receipts|audit|...`, `kind=shape|status|header`).
*   Trace: `cli.request`, `cli.parse`, `cli.render` com `request_id` do gate propagado.
*   Alertas leves quando `mismatch_total` > 0 por N minutos.

* * *

### 9.7 ‚ÄúTest Harness‚Äù √∫nico (reuso por UI)

*   `packages/clients/ubl` (Rust): **SDK** compartilhado (HTTP client + tipos).
*   A CLI importa esse SDK; a UI (TS/WASM ou HTTP bridge) **tamb√©m**.
*   Tests de integra√ß√£o rodam contra um **gate real** ou **stub** que implementa o mesmo **trait** do SDK (in-memory).

* * *

### 9.8 Pol√≠ticas de Vers√£o e Deprecia√ß√£o

*   **SemVer**:
    *   **Major**: quebra de rota/campos/sem√¢ntica ‚Üí RFC + migra√ß√£o.
    *   **Minor**: campos novos, endpoints adicionais.
    *   **Patch**: corre√ß√£o sem efeito no contrato.
*   **Changelog dirigido por CLI**: cada release destaca
    *   Novos comandos/flags.
    *   Campos novos nas respostas.
    *   Aliases adicionados e data de remo√ß√£o.

* * *

### 9.9 Checklists de PR

**Server (gate):**

*    Atualizou `openapi.json`/spec?
*    AppError consistente em todos os handlers novos?
*    Rotas novas t√™m vers√£o (`/v1/...`) e, se substituir antigas, **alias** configurado?
*    Testes: unit + e2e (via CLI) cobrindo sucesso/erro.

**CLI p√∫blica:**

*    Comando tem `--json` fiel ao spec.
*    Flags mapeiam 1:1 com headers/params.
*    Mensagens humanas **separadas** do `--json`.
*    Golden atualizado (`--update` se aprovado).

**UI:**

*    Usa SDK comum (sem fetch manual divergente).
*    E2E roda **usando o mesmo endpoint e shape** da CLI.
*    Story ‚Äúerro do gate‚Äù (AppError) renderiza code/message/retry.

* * *

### 9.10 Exemplos de Casos Limite (inclua na su√≠te)

*   `GET /v1/receipt/{cid}` com `b3:` e **sem** `Content-Type` ‚Üí 200 JSON.
*   `404` de receipt inexistente ‚Üí `AppError` shape ok.
*   Rate-limit: cabe√ßalhos **expostos** via CORS v√°lido.
*   `execute --ghost` repetido 3√ó ‚Üí `tip_cid` id√™ntico.
*   Tenant B **n√£o** enxerga receipt de Tenant A (404).
*   Alias legacy (`/v1/...` vs `/a/{app}/t/{tenant}/v1/...`) quando habilitado.

* * *

### 9.11 Deliverables imediatos

*    Publicar **SDK comum** e apontar CLI e UI para ele.
*    Gerar/commitar `openapi.json` no repo do gate (CI valida drift).
*    Criar `golden/` com 10+ cen√°rios core (auth, execute, receipts, audit, errors).
*    Implantar **template de `alignment:`** e obrigar uso quando UI/CLI quebrar.
*    Adicionar m√©trica `cli_contract_mismatch_total`.

* * *

### 9.12 Resultado esperado

*   **Zero drift percept√≠vel**: qualquer evolu√ß√£o do servidor se reflete **simultaneamente** em CLI e UI.
*   **Onboarding confi√°vel**: demos e scripts reproduz√≠veis usando s√≥ `ublx`.
*   **Debugar vira trivial**: reprodu√ß√µes com **1 comando** e outputs est√°veis.

Se quiser, j√° redijo o `openapi.json` m√≠nimo (handlers de `execute`, `receipt`, `receipts`, `audit`) e a estrutura do SDK para voc√™ plugar no repo.

## Prompt:
10

10) EventBus (Iggy) Plug√°vel
Ap√≥s persistir (ledger), publique ReceiptEvent { scope, phase, cid, parent, decision, ts }. Trait EventBus com impl IggyEventBus. Tests: at-least-once (reprocessamento idempotente), parti√ß√£o por app:tenant.

11) Observabilidade Base
Tracing spans (gate.request, policy.decide, runtime.exec, ledger.put, event.publish), Prometheus (pass/deny/retry; hist de exec), e dashboard m√≠nimo. Testes de m√©tricas: exporta e conta passa.

12) Receipt UI (Canvas) ‚Üí Integra√ß√£o
A p√°gina do canvas j√° est√° est√°vel (corrigido o ) no copy). Pr√≥ximos passos:
	‚Ä¢	Ligar ?cid=... ‚Üí fetch real, com ‚ÄúDemo Mode‚Äù quando sem cid.
	‚Ä¢	‚ÄúVerify‚Äù abrir guia com instru√ß√µes (CLI ublx verify + libs).
	‚Ä¢	Testes leves j√° existem; adicione: PASS/RETRY/DENY altera progress, popovers acess√≠veis (aria), ‚ÄúCopy All‚Äù inclui links.self, e modo impress√£o exibe faixa de autenticidade.

## Response:
Cap√≠tulo 10/12 ‚Äî EventBus (Iggy) Plug√°vel
-----------------------------------------

**Objetivo:** ap√≥s persistir no **ledger**, publicar um **ReceiptEvent** em um backbone de eventos para proje√ß√µes ass√≠ncronas (indexer, buscas, auditor, webhooks). Garantias: _at-least-once_, ordena√ß√£o por **(app:tenant)**, deduplica√ß√£o simples por **event\_id** e lat√™ncia baixa.

* * *

### 10.1 Esquema do evento (est√°vel)

Envelope m√≠nimo ‚Äî imut√°vel e versionado:

```json
{
  "v": 1,
  "event_id": "evt_b3:...",           // b3 do pr√≥prio evento (CID do JSON can√¥nico)
  "scope": { "app": "dan-projects", "tenant": "profissional" },
  "phase": "WA|TR|WF",
  "cid": "b3:...",                    // body_cid do recibo da fase
  "parent": "b3:...|null",            // encadeamento WA->TR->WF
  "decision": "PASS|RETRY|DENY|null", // s√≥ em WF
  "ts": "2026-02-14T14:22:08Z"        // carimbo do Gate (derivado do receipt)
}
```

Regras:

*   **Partition key:** `"{app}:{tenant}"`.
*   **Key do registro no broker:** `event_id`.
*   **Schema evolution:** apenas _additive_; campos novos t√™m `serde(default)` nos consumidores.

* * *

### 10.2 Abstra√ß√£o plug√°vel

```rust
#[async_trait::async_trait]
pub trait EventBus: Send + Sync {
    async fn publish(&self, topic: &str, partition_key: &str, key: &[u8], value: &[u8]) -> anyhow::Result<()>;
    async fn health(&self) -> anyhow::Result<()>;
}

pub struct NoopBus;
#[async_trait::async_trait]
impl EventBus for NoopBus {
    async fn publish(&self, _: &str, _: &str, _: &[u8], _: &[u8]) -> anyhow::Result<()> { Ok(()) }
    async fn health(&self) -> anyhow::Result<()> { Ok(()) }
}
```

**Contrato operacional do Gate:** `ledger.put` **antes**, `bus.publish` **depois**; em falha, retornar **200** do recibo, mas logar/metricar erro de publica√ß√£o e disparar **retry** ass√≠ncrono.

* * *

### 10.3 Iggy implementation (prod) + mem√≥ria (test)

```rust
pub struct IggyEventBus {
    client: iggy::Client,            // cliente oficial
    topic_receipts: String,          // ex.: "receipts"
    acks: iggy::Acks,                // ex.: Acks::Leader
    timeout: Duration,               // ex.: 500ms
}

#[async_trait::async_trait]
impl EventBus for IggyEventBus {
    async fn publish(&self, topic: &str, part_key: &str, key: &[u8], val: &[u8]) -> anyhow::Result<()> {
        let partition = iggy::partition_from_key(part_key);
        self.client
            .produce(topic, partition)
            .key(key)
            .value(val)
            .acks(self.acks)
            .timeout(self.timeout)
            .send()
            .await?;
        Ok(())
    }
    async fn health(&self) -> anyhow::Result<()> {
        self.client.ping().await.map_err(Into::into)
    }
}
```

**Bus em mem√≥ria** (para testes/unit):

```rust
#[derive(Default, Clone)]
pub struct MemBus(pub Arc<Mutex<Vec<(String,String,Vec<u8>,Vec<u8>)>>>);

#[async_trait::async_trait]
impl EventBus for MemBus {
    async fn publish(&self, t:&str, k:&str, key:&[u8], val:&[u8]) -> anyhow::Result<()> {
        self.0.lock().unwrap().push((t.to_string(), k.to_string(), key.to_vec(), val.to_vec()));
        Ok(())
    }
    async fn health(&self) -> anyhow::Result<()> { Ok(()) }
}
```

* * *

### 10.4 Publica√ß√£o no fluxo do Gate

No handler `execute_runtime` (ap√≥s persistir WA/TR/WF):

```rust
let evt = ReceiptEvent::from(&receipt, &scope);        // monta JSON can√¥nico v1
let evt_bytes = to_canonical_json(&evt)?;              // NRF-like (ordenado)
let event_id = blake3_multibase(&evt_bytes);           // ‚Äúevt_b3:...‚Äù
let key = event_id.as_bytes();
let part = scope.partition_key();                      // "app:tenant"

// publish sem bloquear resposta do cliente
let bus = state.event_bus.clone();
let topic = state.cfg.topics.receipts.clone();
tokio::spawn(async move {
    let _ = bus.publish(&topic, &part, key, &evt_bytes).await
        .map_err(|e| tracing::error!(%event_id, %part, "event_publish_error={e}"));
});
```

**Motivo do `spawn`:** a publica√ß√£o n√£o afeta a _durabilidade_ do recibo (j√° persistido). Erro vira telemetria + retry (ver ¬ß10.7).

* * *

### 10.5 Particionamento e ordena√ß√£o

*   **T√≥pico √∫nico:** `receipts`.
*   **N parti√ß√µes** (‚â• n√∫mero de tenants / throughput).
*   **Chave de parti√ß√£o:** `app:tenant` ‚Üí **ordem relativa preservada** por escopo.
*   **Consumidores oficiais**:
    *   `indexer` (idempotente por `event_id`),
    *   `audit-proj` (sum√°rios),
    *   `searcher` (Tantivy),
    *   `webhook-bridge` (entrega externa resiliente).

* * *

### 10.6 Idempot√™ncia & at-least-once

**Garantias:**

*   Gate pode publicar **duas vezes** (retry, crash depois de persistir).
*   Consumidor **deve** fazer _dedupe_ por `event_id`.

Padr√£o de consumidor:

```rust
// pseudo-c√≥digo
loop {
  let msg = consumer.next().await?;
  let evt: ReceiptEvent = parse(msg.value)?;
  if dedupe_store.seen(&evt.event_id) { consumer.ack(msg); continue }
  apply_projection(evt).await?;
  dedupe_store.mark(&evt.event_id);
  consumer.ack(msg);
}
```

**Dedupe store**: LRU+TTL (mem√≥ria) + persist√™ncia leve (SQLite ou RocksDB) para crash-recovery.

* * *

### 10.7 Retry, DLQ e backpressure

*   **Retry no Gate:** fila em mem√≥ria com _jitter_ exponencial (ex.: 100ms‚Üí1s‚Üí5s‚Üí30s) limitada por escopo.
*   **DLQ (opcional no in√≠cio):** um t√≥pico `receipts.dlq` para eventos que falham N vezes seguidas (marcar `reason`, `last_error`).
*   **Backpressure:** se `publish` bloquear > `timeout`, logue `warn` e enfileire retry; nunca bloqueie a resposta do `/execute`.

* * *

### 10.8 Configura√ß√£o

`ENV` (exemplos):

```
IGGY_BROKER_ADDR=iggy://localhost:8090
IGGY_TOPIC_RECEIPTS=receipts
IGGY_ACKS=leader
IGGY_TIMEOUT_MS=500
EVENTS_ENABLED=1
```

Se `EVENTS_ENABLED=0`, inicializar `NoopBus` (feature flag para ambientes m√≠nimos).

* * *

### 10.9 Seguran√ßa

*   **Rede:** Iggy com TLS mTLS quando dispon√≠vel; caso contr√°rio, t√∫nel restrito (ex.: rathole).
*   **AutZ no Gate:** o conte√∫do do evento √© **p√∫blico interno** (n√£o cont√©m PII sens√≠vel por design), mas o broker exige **credenciais** do Gate/consumidores oficiais.
*   **Hardening:** limitar quem pode criar t√≥picos/parti√ß√µes; pol√≠tica de reten√ß√£o (ex.: 7‚Äì30 dias) + _compaction_ por `key`.

* * *

### 10.10 Testes

**Unit (bus/serdes):**

*   Serializa√ß√£o can√¥nica (ordem de chaves ‚Üí `event_id` est√°vel).
*   `MemBus` recebe `(topic, partition_key, key=event_id, value)` corretos.

**Integration (Gate + MemBus):**

1.  **Publica WF ap√≥s persistir**
    *   Chamar `/execute` ‚Üí assert de que `MemBus` recebeu 3 eventos (WA, TR, WF) na ordem, mesma `partition_key`.
2.  **At-least-once**
    *   Simular erro na 1¬™ publica√ß√£o ‚Üí retry ‚Üí **dois** eventos id√™nticos no bus; consumidor idempotente aplica 1x.
3.  **Particionamento por escopo**
    *   Executar em dois tenants ‚Üí verificar `partition_key` diferentes e **ordem relativa** por escopo.
4.  **Desligado (Noop)**
    *   `EVENTS_ENABLED=0` ‚Üí nenhum publish, recibo ok.

**E2E (Iggy real opcional):**

*   Subir broker, criar t√≥pico `receipts` com N parti√ß√µes.
*   Rodar `ublx execute --ghost` 10x ‚Üí consumir e conferir sequ√™ncia WA‚ÜíTR‚ÜíWF; lat√™ncia p50/p99.

* * *

### 10.11 Observabilidade

M√©tricas no Gate:

*   `event_publish_total{result="ok|err", phase, app, tenant}`
*   `event_publish_latency_seconds{phase}` (histograma)
*   `event_retry_queue_depth{app,tenant}`

Tracing:

*   `event.publish` (attrs: `event_id`, `phase`, `partition_key`, `topic`)
*   Correlacionar com `request_id` do `/execute`.

Alertas:

*   Taxa de erro de publish > 1% por 5 min.
*   Fila de retry acima de limiar.

* * *

### 10.12 Migra√ß√£o & compat

*   **Fase 1 (shadow):** publicar eventos **al√©m** do comportamento atual; consumidores podem ignorar.
*   **Fase 2:** habilitar indexer/search/audit _apenas_ via EventBus (sem varrer pastas).
*   **Compat:** `event.v` no payload; mudan√ßas _breaking_ exigem novo `v`.

* * *

### 10.13 Entreg√°veis

*   `event.rs`: `ReceiptEvent` + `to_canonical_json()`.
*   `bus.rs`: `EventBus`, `NoopBus`, `MemBus`, `IggyEventBus`.
*   `cfg`: parsing de ENV + `AppState { event_bus }`.
*   Wiring no `execute_runtime` (publica WA/TR/WF).
*   Testes unit + integra√ß√£o (MemBus) + opcional E2E (Iggy).
*   M√©tricas/Tracing e dashboards m√≠nimos.

* * *

### 10.14 Resultado

*   Proje√ß√µes reativas, isolamento por escopo, **at-least-once** robusto com dedupe simples e lat√™ncia baixa.
*   O **modelo receipt-first** permanece a fonte de verdade; o EventBus √© o **sistema nervoso** do ecossistema.

## Prompt:
11

## Response:
Cap√≠tulo 11/12 ‚Äî Observabilidade Base
-------------------------------------

Objetivo: tornar o **gate** e o **runtime** introspect√°veis ‚Äúde f√°brica‚Äù, com **tracing** consistente, **m√©tricas Prometheus** acion√°veis, logs estruturados e um **dashboard m√≠nimo**. O foco √© medir: volume/lat√™ncia por fase (WA/TR/WF), decis√µes (PASS/RETRY/DENY), erros (por c√≥digo), CORS/limiter/idempot√™ncia, e publica√ß√£o no EventBus.

* * *

### 11.1 Padr√µes e depend√™ncias

*   **Tracing:** `tracing`, `tracing-subscriber`, `tracing-error`, `opentelemetry` (opcional).
*   **M√©tricas:** `metrics`, `metrics-exporter-prometheus` (pull-based em `/metrics`).
*   **Logs:** `tracing` ‚Üí **JSON** (um por linha), com `request_id`, `scope.app`, `scope.tenant`.

```rust
// no lib.rs (app_with_state)
use metrics_exporter_prometheus::PrometheusBuilder;
use tracing_subscriber::{EnvFilter, fmt, layer::SubscriberExt, util::SubscriberInitExt};

fn init_obs() -> Option<metrics_exporter_prometheus::PrometheusHandle> {
    // tracing
    let fmt_layer = fmt::layer()
        .json()
        .with_timer(fmt::time::UtcTime::rfc_3339())
        .with_target(false)
        .with_file(false)
        .with_line_number(false);
    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| "info,hyper=warn,axum=warn".into());
    tracing_subscriber::registry().with(filter).with(fmt_layer).init();

    // metrics /metrics
    let builder = PrometheusBuilder::new();
    let handle = builder.install_recorder().ok()?;
    Some(handle)
}
```

Expor `/metrics`:

```rust
let handle = init_obs();
let state = AppState { metrics_handle: handle.clone(), ..Default::default() };

let metrics_router = Router::new().route("/metrics", get({
    let h = handle.clone();
    move || async move {
        if let Some(h) = &h { (StatusCode::OK, h.render()) } else { (StatusCode::SERVICE_UNAVAILABLE, "") }
    }
}));
```

* * *

### 11.2 Conven√ß√µes de spans

*   Span raiz por requisi√ß√£o: `gate.request`  
    Atributos: `request_id`, `method`, `path`, `scope.app`, `scope.tenant`, `auth.sub`, `client_id`.
*   Sub-spans:
    *   `policy.decide` (uma por pol√≠tica; attrs: `policy_id`, `decision`)
    *   `runtime.exec` (attrs: `runtime.cid`, `bytes_in/out`)
    *   `ledger.put` / `ledger.get` (attrs: `cid`, `kind=receipt|transition`)
    *   `event.publish` (attrs: `event_id`, `phase`, `partition_key`, `topic`)
    *   `cors.check` (attrs: `origin`, `scope`, `allowed`)
    *   `rate.check` (attrs: `key`, `burst`, `remaining`)
    *   `idemp.check` (attrs: `key`, `result=New|Replay|InProgress|Expired|Evicted`)

Exemplo no handler:

```rust
#[tracing::instrument(
    name="gate.request",
    skip(state, body),
    fields(request_id=%req_id, method=%method, path=%path, app=%scope.app, tenant=%scope.tenant)
)]
async fn execute_runtime(State(state): State<AppState>, scope: Scope, body: Json<Manifest>) -> Result<Json<Receipt>, AppError> {
    // ...
    let _span = tracing::info_span!("runtime.exec", runtime_cid=%state.runtime_sha256).entered();
    // chama runtime...
}
```

Erros com contexto:

```rust
tracing::error!(error=%e, code=%code, "execute_failed");
return Err(AppError::internal("runtime_error"));
```

* * *

### 11.3 M√©tricas Prometheus

**Contadores:**

*   `gate_requests_total{method,route,app,tenant}`
*   `gate_responses_total{status,route,app,tenant}`
*   `gate_policy_decisions_total{policy_id,decision,app,tenant}`
*   `gate_event_publish_total{result="ok|err",phase,app,tenant}`
*   `gate_idempotency_total{result,app,tenant}`
*   `gate_rate_limit_drops_total{app,tenant,client_id}`
*   `gate_cors_origin_checks_total{result="allow|deny",scope,app,tenant}`
*   `ledger_ops_total{op="put|get",kind,app,tenant}`

**Histogramas:**

*   `gate_request_duration_seconds{route,app,tenant}`
*   `runtime_exec_seconds{pipeline}`
*   `ledger_put_seconds{kind}`
*   `event_publish_seconds{phase}`

**Gauges:**

*   `event_retry_queue_depth{app,tenant}`
*   `idempotency_store_size`
*   `rate_bucket_remaining{app,tenant,client_id}`

Exemplo de uso:

```rust
use metrics::{counter, histogram, gauge};

counter!("gate_requests_total", 1, "method"=>method, "route"=>route, "app"=>app, "tenant"=>tenant);
let t0 = std::time::Instant::now();
// ...processa...
histogram!("gate_request_duration_seconds", t0.elapsed().as_secs_f64(), "route"=>route, "app"=>app, "tenant"=>tenant);
```

* * *

### 11.4 Cabe√ßalhos de resposta

Padronizar **RateLimit** e **Request-ID**:

*   `X-Request-Id` (ecoado do middleware)
*   `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `Retry-After` (quando aplic√°vel)

Liberar via CORS: `access-control-expose-headers: x-ratelimit-limit,x-ratelimit-remaining,retry-after,x-request-id`.

* * *

### 11.5 SLOs e alertas

SLO iniciais (7 dias):

*   **Disponibilidade API**: 99.9% de 2xx/3xx (exclui 4xx).
*   **Lat√™ncia p95 `/v1/execute`**: ‚â§ 250 ms.
*   **Erro de publish**: < 1% por 5 min.

Alertas Prometheus/Alertmanager:

*   `sum by(app,tenant)(rate(gate_event_publish_total{result="err"}[5m])) > 0`
*   `histogram_quantile(0.95, sum by (le)(rate(gate_request_duration_seconds_bucket{route="/v1/execute"}[5m]))) > 0.25`
*   `sum by(app,tenant)(increase(gate_rate_limit_drops_total[5m])) > 100`

* * *

### 11.6 Dashboard m√≠nimo (Grafana)

**Painel 1 ‚Äî Tr√°fego e Sucesso**

*   `gate_requests_total` por rota
*   % respostas 2xx/4xx/5xx empilhado
*   p50/p95/p99 `gate_request_duration_seconds` (por rota)

**Painel 2 ‚Äî Pipeline**

*   `runtime_exec_seconds` (p95) por pipeline
*   `gate_policy_decisions_total{decision}` por policy
*   `ledger_ops_total` (put/get) + `ledger_put_seconds` p95

**Painel 3 ‚Äî EventBus**

*   `gate_event_publish_total{result}`
*   `event_publish_seconds` p95
*   `event_retry_queue_depth`

**Painel 4 ‚Äî Limiter/Idempot√™ncia/CORS**

*   `gate_rate_limit_drops_total` por client\_id
*   `gate_idempotency_total{result}`
*   `gate_cors_origin_checks_total{result}`

* * *

### 11.7 Testes automatizados

**Unit (sem rede):**

*   Emiss√£o de m√©tricas por caminho feliz/erro (usa `metrics_util::debugging::DebuggingRecorder`).
*   Spans carregam `app`, `tenant`, `request_id`.

**Integra√ß√£o (supertest do Axum):**

1.  `/healthz` ‚Üí `gate_requests_total` incrementa e `/metrics` exp√µe.
2.  `/v1/execute` PASS ‚Üí incrementa `gate_policy_decisions_total{decision="PASS"}` e registra histograma > 0.
3.  Rate limit breach ‚Üí `gate_rate_limit_drops_total` > 0 e cabe√ßalhos `X-RateLimit-*`.
4.  CORS `Origin` permitido/negado ‚Üí `gate_cors_origin_checks_total{result=...}`.
5.  Event publish erro simulado (bus `MemBus` que falha 1x) ‚Üí `gate_event_publish_total{result="err"}` seguido de ‚Äúok‚Äù.

**E2E (opcional):**

*   Com Iggy/Prometheus reais em docker-compose; valida scrape e pain√©is.

* * *

### 11.8 Boas pr√°ticas

*   **Amostragem de tracing**: produ√ß√£o com 10‚Äì20% em rotas quentes; 100% em erros.
*   **PII**: nunca logar payload; logar **CIDs** e `request_id`.
*   **Correlacionar**: propagar `request_id` em spans filhos e logs.
*   **Backpressure**: n√£o bloquear caminho de resposta por falhas de telemetria.

* * *

### 11.9 Entreg√°veis

*   `obs.rs` (init de tracing + prometheus; helper para `X-Request-Id`).
*   Middlewares: request-id, m√©tricas de request, expose headers CORS.
*   Instrumenta√ß√£o nos pontos: policy, runtime, ledger, eventbus, cors, limiter, idemp.
*   `/metrics` route.
*   Painel Grafana (JSON) e regras de alerta.
*   Testes unit + integra√ß√£o cobrindo m√©tricas/spans essenciais.

* * *

### 11.10 Resultado

Com poucos arquivos e padr√µes claros, voc√™ ganha **visibilidade operacional real**: sabe **quanto**, **qu√£o r√°pido** e **qu√£o bem** cada fase est√° performando, detecta regress√µes, tem **SLOs acion√°veis** e um dashboard que conversa diretamente com o seu modelo **receipt-first**.

## Prompt:
12

## Response:
Cap√≠tulo 12/12 ‚Äî Receipt UI (Canvas) ‚Üí Integra√ß√£o
-------------------------------------------------

Objetivo: ligar a **UI de Recibo** (canvas) ao **gate** real, mantendo o modo ‚ÄúDemo‚Äù quando n√£o houver `cid`, suportando `b3:` em URLs, bot√µes ‚ÄúCopy/Verify/Deep-link‚Äù funcionais, acessibilidade completa e impress√£o s√≥bria.

* * *

### 12.1 Contratos de API (vers√£o est√°vel)

*   **GET** `/a/{app}/t/{tenant}/v1/receipt/{cid}`  
    Retorna:
    ```json
    {
      "decision": "PASS|RETRY|DENY",
      "cid": "cid:b3:...",
      "runtime": {"did": "did:key:..."},
      "jws": {
        "alg": "Ed25519",
        "protected": {"kid":"did:key:..."},
        "payload": "0x..."
      },
      "links": {
        "self": "https://gate/a/{app}/t/{tenant}/v1/receipt/{cid}",
        "verify": "https://gate/a/{app}/t/{tenant}/v1/verify/{cid}"
      },
      "policy_trace": [{ "id":"policy-xyz", "decision":"PASS|RETRY|DENY" }]
    }
    ```
*   **Cabe√ßalhos**: `X-Request-Id`, `X-RateLimit-*`, `Retry-After` (expostos via CORS).
*   **Erros (JSON)** via `AppError`:
    ```json
    {"code":"not_found","message":"receipt not found","request_id":"...","retry_after":0}
    ```

Observa√ß√µes:

*   N√£o exigir `Content-Type` em **GET**.
*   `cid` aceita `b3:` literal (tamb√©m URL-encoded).

* * *

### 12.2 Protocolo de binding (UI ‚Üí gate)

1.  **Resolver escopo** da URL:
    *   Query: `?cid=...&app=...&tenant=...`
    *   Ou path ‚Äúfriendly‚Äù: `/#/a/{app}/t/{tenant}/cid/{cid}` (UI reescreve para fetch).
2.  **Demo Mode**: quando faltar `cid`, usar objeto de amostra (o que j√° est√° no canvas) e exibir ‚ÄúDemo Mode‚Äù.
3.  **Fetch**:
    *   `Authorization: Bearer ‚Ä¶` quando existir (UI p√∫blica pode omitir).
    *   `Accept: application/json`.

**Snippet (substitui o ‚Äúdemo data‚Äù do canvas com fallback elegante):**

```html
<script>
async function loadReceipt() {
  const qs = new URLSearchParams(location.search);
  const app    = qs.get('app');
  const tenant = qs.get('tenant');
  const cid    = qs.get('cid');

  // Demo Mode quando faltar cid/app/tenant
  if (!cid || !app || !tenant) return { demo:true };

  const base = location.origin; // ou env injetado na build
  const url  = `${base}/a/${encodeURIComponent(app)}/t/${encodeURIComponent(tenant)}/v1/receipt/${encodeURIComponent(cid)}`;

  const headers = { 'Accept':'application/json' };
  const token = sessionStorage.getItem('ubl_token') || '';
  if (token) headers['Authorization'] = `Bearer ${token}`;

  const res = await fetch(url, { headers });
  if (!res.ok) {
    const err = await res.json().catch(()=>({message:res.statusText, code:String(res.status)}));
    throw Object.assign(new Error(err.message||'Erro'), { code:err.code||String(res.status), requestId: res.headers.get('x-request-id') });
  }
  const body = await res.json();

  // normalizar campos m√≠nimos esperados pela UI
  return {
    demo:false,
    decision: body.decision,
    cid: body.cid,
    jws: body.jws,
    runtime: body.runtime,
    links: body.links,
    policy_trace: body.policy_trace || []
  };
}
</script>
```

**Hook no canvas existente (troca o IIFE `(receipt)` por `await loadReceipt()`):**

```html
<script>
(async function main(){
  try {
    const r = await loadReceipt();
    // preencher demo badge
    if (r.demo) document.getElementById('demoBadge').style.display='inline-flex';

    // reaproveita bind() j√° existente
    (function bind(receipt){
      // ... (seu c√≥digo atual de bind) ...
    })(Object.assign({
      decision:'PASS',
      cid:'cid:b3:QmXYZ123‚Ä¶9v',
      jws:{alg:'Ed25519', protected:{kid:'did:key:z6Mk‚Ä¶'}, payload:'0x82f‚Ä¶a1c9'},
      links:{ self: location.origin + '/v1/receipts/cid:b3:QmXYZ123‚Ä¶9v', verify: location.origin + '/v1/verify/cid:b3:QmXYZ123‚Ä¶9v' },
      runtime:{did:'did:key:z6Mk‚Ä¶'}
    }, r.demo ? {} : r));
  } catch (e) {
    // Mostrar erro ‚Äúconfi√°vel‚Äù
    const pre = document.createElement('pre');
    pre.className='mono card';
    pre.textContent = `Falha ao carregar recibo\ncode=${e.code||'unknown'}\nrequest_id=${e.requestId||'-'}\nmsg=${e.message}`;
    document.querySelector('.sheet').appendChild(pre);
  }
})();
</script>
```

* * *

### 12.3 Intera√ß√µes confi√°veis

*   **Copy/Deep-link/Verify**: j√° mapeados; ‚ÄúVerify‚Äù abre guia com instru√ß√µes para `ublx verify {cid}` (incluir doc curta).
*   **Explainers**: popovers (`.pop`) com ARIA e dismiss on click-outside j√° prontos.
*   **Progress bar**: 33/66/100% conforme `decision`.
*   **Print strip**: `footer#authStrip` aparece apenas no modo impress√£o.

Adicionar **links de verifica√ß√£o**:

```html
<script>
document.getElementById('doc-verify').addEventListener('click', (e)=>{
  e.preventDefault();
  const url = 'https://docs.seu-dominio/verify'; // doc curta com ublx/TS/Py
  window.open(url,'_blank','noreferrer');
});
</script>
```

* * *

### 12.4 Acessibilidade (checagem)

*   `aria-live="polite"` nos toasts (j√° h√° `#live`).
*   Toolbar com `role="toolbar"` e `aria-label`.
*   Popovers com `aria-controls`, `aria-expanded`; fechar com `Esc`.
*   Contraste e foco vis√≠veis nos `.chip` (`aria-pressed` tempor√°rio).
*   `prefers-reduced-motion` respeitado.

* * *

### 12.5 Telemetria de UI

Enviar _beacons_ opcionais (sem PII) ao abrir/fechar popovers, copy/verify, impress√£o:

```js
function beacon(ev, extra={}) {
  try { navigator.sendBeacon('/telemetry/ui', JSON.stringify({ev, t:Date.now(), ...extra})); } catch {}
}
```

* * *

### 12.6 Testes (UI)

1.  **Unit (no browser com `vitest`/`uvu` ou leve IIFE como j√° existe):**
    *   `copy()` retorna Promise.
    *   Status aplicado ao `<body data-status>`.
    *   Progress ‚â• 33% e coerente com `decision`.
    *   Popovers alternam `aria-expanded`.
2.  **Integra√ß√£o (mock fetch):**
    *   `b3:` literal e `%3A` funcionam.
    *   Erro JSON do gate √© renderizado com `request_id`.
3.  **A11y (axe-core)**: sem viola√ß√µes cr√≠ticas.
4.  **Print**: snapshot visual (Playwright) com faixa de autenticidade vis√≠vel.
5.  **‚ÄúCopy All‚Äù** inclui `links.self`.

Exemplo de teste leve j√° embutido no canvas: mantenha e acrescente checagem de `links.self` copiado.

* * *

### 12.7 Seguran√ßa e CORS

*   UI s√≥ consome **GET**; CORS deve permitir `GET`, `Authorization`, `X-Request-Id` e expor `x-ratelimit-*`, `retry-after`, `x-request-id`.
*   Preflight: predicate resolve **scope** do caminho (`/a/{app}/t/{tenant}/‚Ä¶`), como voc√™ j√° ajustou no gate.

* * *

### 12.8 Deploy

*   **No-cache** controlado (ex.: `Cache-Control: no-store` durante testes).
*   **Env**: `GATE_BASE_URL`, `PUBLIC_DOC_VERIFY_URL`.  
    Se ausente, usa `location.origin`.

* * *

### 12.9 Pr√≥ximos incrementos

*   **Policy Trace UI**: se√ß√£o colaps√°vel listando cada pol√≠tica, decis√£o e notas.
*   **Diff WA‚ÜíWF**: micro-viewer que mostra o que mudou.
*   **Share Link** assinado: gerar deep-link com HMAC (expira√ß√£o curta) quando necess√°rio.
*   **Tema claro/escuro** via `prefers-color-scheme`.

* * *

### 12.10 Resultado

A p√°gina do canvas passa a operar **direto no recibo real** quando houver `cid/app/tenant`, cai em **Demo Mode** quando n√£o houver, preserva **seguran√ßa de leitura**, comunica **provas** com clareza e imprime um **recibo s√≥brio** com trilha de autenticidade ‚Äî tudo coerente com o n√∫cleo **receipt-first**.

## Prompt:
*Nao olha o canvas*

Consegue ler as √∫ltimas 12 mensagens e ver se gostou?

2/2

## Response:
Gostei muito ‚Äî est√° coeso, incremental e com foco em prova/qualidade. Eis meu review das 12, com elogios e apertos onde d√° para lapidar mais.

### O que ficou excelente

*   **N√∫cleo imut√°vel + packs est√°ticos**: fecha a porta para drift e injec√ß√£o din√¢mica. √ìtimo voc√™ atrelar `runtime.sha256`/`did` no recibo.
*   **Scope first (app/tenant)** em CORS, rate limit, storage e rotas: alinhou tudo no mesmo eixo.
*   **Idempot√™ncia** com chave `(app, tenant, method, path, idemp_key, body_sha)` e **seq monot√¥nico**: resolve empate de `Instant`. Boa cobertura de testes.
*   **Receipt API** ‚Äú√† prova de `b3:`‚Äù + `AppError` JSON est√°vel: DX muito melhor; tamb√©m acerta a UI e o battle.
*   **Battle e2e**: for√ßa o caminho correto (user ‚Üí app ‚Üí tenant), cobre auth on, CORS 3 camadas, determinismo com `ghost:true`, auditoria antes/depois e isolamento.
*   **CLI p√∫blica como contrato**: esse guard-rail evita descompasso de longo prazo e d√° um roteiro claro de ‚Äúalignment issues‚Äù.
*   **EventBus plug√°vel (Iggy)** com evento m√≠nimo e parti√ß√£o por `app:tenant`: casa perfeito com proje√ß√µes e produtos sat√©lite.
*   **Observabilidade** com spans e m√©tricas nomeadas: d√° material direto para SLOs.
*   **UI do recibo**: interativa, explicativa, print s√≥brio, e com caminho de ‚ÄúDemo ‚Üí real‚Äù bem definido.

### Onde eu apertaria mais (pequenos refinamentos)

1.  **Chave de idempot√™ncia**  
    Inclua `query_sha` (hash de querystring normalizada) e **vers√£o do contrato** (`contract_rev`) para blindar futuros params ou mudan√ßas de schema.
2.  **Rate limit**  
    Especifique explicitamente janelas (ex.: token bucket 60s) e **limites por m√©todo** (GET vs POST). Teste headers CORS expostos em **preflight** tamb√©m.
3.  **AppError**  
    Mantenha enum est√°vel de `code` (`invalid_cid`, `not_found`, `rate_limited`, `unauthorized`, `forbidden`, `idempotency_replay`) e **mapeamento 1:1** com HTTP status. Adicione `hint` opcional quando seguro.
4.  **Receipts store**  
    Confirme **chave dupla**: `scoped_cid` (oficial) e `cid puro` (legado) com TTL de migra√ß√£o. Teste ‚Äúlookup por scoped‚Äù primeiro, depois fallback.
5.  **Battle script**  
    Adicione checks de **headers** (`X-RateLimit-*`, `X-Request-Id`, `Retry-After`), e um bloco de **reprocessamento at-least-once** consumindo o EventBus e validando idempot√™ncia do indexer.
6.  **EventBus**  
    Persistir `offset_cid` ou `event_id` no recibo WF (ou metadado) facilita auditorias de entrega. Teste ‚Äúduplo publish‚Äù e ‚Äúconsumidor lento‚Äù.
7.  **Tracing**  
    Propague `request_id` como **trace id** ra√≠z quando poss√≠vel; inclua `cid` e `scope` como attributes em todas as spans.
8.  **UI verify**  
    Forne√ßa snippet direto de `ublx verify {cid}` + equivalente TS/Py, e teste de acessibilidade (axe) como parte do CI da UI.
9.  **SemVer/compat**  
    J√° que a CLI √© ‚Äúfonte da verdade‚Äù, publique uma **matrix de compat** (CLI x gate x runtime) e um teste que recuse CLI muito antiga com erro claro.
10.  **Seguran√ßa**  
    Garanta `Allow-Origin` **exato** (sem `*` com credenciais), `Vary: Origin`, e normalize `Origin`/`Host` em preflight para evitar bypass de wildcard intermedi√°rio.

### Mini-ajustes de reda√ß√£o/ordem

*   A sequ√™ncia **6‚Üí7‚Üí8** est√° √≥tima; s√≥ reforce no 7 que **GET** nunca exige `Content-Type`, e documente os **exemplos b3:** com e sem `%3A`.
*   No 10, deixe claro o **ponto de publica√ß√£o**: ‚Äúpublish s√≥ **ap√≥s** persistir (ledger) e antes de responder‚Äù, e que o consumidor deve ser **idempotente** por `cid`.

### Pequenas pend√™ncias que eu fecharia j√°

*   Teste de **preflight**: `OPTIONS /a/{app}/t/{tenant}/v1/execute` com `Origin` permitido e bloqueado, validando `Access-Control-*`.
*   Teste de **impress√£o** da UI (snapshot Playwright) com a faixa de autenticidade.
*   **Doc curta** ‚ÄúAlignment Issue Template‚Äù (os 3 campos que voc√™ descreveu) no reposit√≥rio.

No geral: est√° redondinho e pronto pra crescer, com excelente equil√≠brio entre seguran√ßa, DX e auditabilidade. Se quiser, eu escrevo os testes extras de preflight e o snippet de verifica√ß√£o CLI/TS/Py para colar direto no docs.

## Prompt:
Faltou um pouco as minhas ideias n√©.. :(

## Response:
Thought for 4 seconds

Verdade, Dan ‚Äî eu deixei pouco do teu ‚Äúsotaque‚Äù ali. Vamos encaixar as tuas ideias direto no plano, sem perder o que j√° est√° s√≥lido. Aqui vai o ajuste cir√∫rgico por t√≥pico, com frases prontas pra colar nas se√ß√µes correspondentes:

### Onboarding (Mensagens 2‚Äì4)

*   **Ordem can√¥nica: usu√°rio ‚Üí app ‚Üí tenant.**  
    ‚ÄúO sistema primeiro cria o **usu√°rio**; imediatamente detecta que ele n√£o pode interagir sem **app** e **tenant**. Entrar em um app/tenant depende da pol√≠tica do admin (livre ou convite).‚Äù
*   **Convites por e-mail com token j√° autenticado.**  
    ‚ÄúSe o usu√°rio abrir o convite j√° logado, o aceite √© 1-clique (sem re-digitar c√≥digo, app\_id ou tenant\_id).‚Äù
*   **Confirma√ß√£o de e-mail (Cloudflare).**  
    ‚ÄúAdicionar verifica√ß√£o via provedor do Cloudflare; at√© confirmar, escopo s√≥ permite leitura de perfil e aceite de convites.‚Äù

### URL-first (Mensagens 3, 6 e 7)

*   **Tudo √© chip: CID/DID na URL carregam o contexto.**  
    ‚ÄúAs rotas **/{a}/{app}/{t}/{tenant}/v1/** s√£o a fonte de verdade do escopo; **b3:** no `cid` √© aceito cru ou URL-encoded; o **DID** do runtime √© exibido e verific√°vel.‚Äù
*   **Sem exigir `Content-Type` em GET.**  
    ‚Äú`GET /v1/receipt/{cid}` nunca exige `Content-Type`; respostas padronizadas `AppError{code,message,request_id,retry_after}`.‚Äù

### CLI-first (Mensagens 8 e 9)

*   **UI e testes espelham a CLI p√∫blica.**  
    ‚ÄúA **CLI p√∫blica** √© o contrato; a UI s√≥ a orquestra. Se CLI-admin ‚Üî API divergirem, abrir ‚Äòalignment issue‚Äô com: contrato esperado, contrato atual, teste reprodutor.‚Äù
*   **Onboarding via CLI, sem atalhos.**  
    ‚ÄúSempre: **user ‚Üí app ‚Üí tenant**. Evita tenants ‚Äú√≥rf√£os‚Äù e mant√©m trilha de recibos do onboarding.‚Äù

### ‚ÄúDraft ‚Üí Oficial‚Äù pelo Gate (Mensagem 8 e 12)

*   **Promo√ß√£o de rascunho a oficial.**  
    ‚ÄúNo tenant profissional-individual, enviar um documento ‚Äòrascunho‚Äô pelo **gate** o transforma em **Oficial** quando passa pelo runtime e vira **Receipt WF**. Terceiros podem usar o mesmo pipeline no escopo deles, com suas pol√≠ticas.‚Äù

### CORS por escopo (Mensagem 6/8)

*   **Tr√™s camadas: global ‚Üí app ‚Üí (app,tenant).**  
    ‚ÄúPredicado resolve escopo pela **URL** (funciona em preflight). Cabe√ßalhos `X-RateLimit-*` expostos; testes de preflight cobrindo permitido/bloqueado.‚Äù

### Rate limit e Idempot√™ncia (Mensagens 5 e 6)

*   **Chaves alinhadas ao teu modelo.**  
    ‚ÄúIdempot√™ncia: `(app,tenant,method,path,idemp_key,body_sha,query_sha,contract_rev)` com seq monot√¥nico.  
    Rate limit: `(app,tenant,client_id)` com janelas por m√©todo; exp√µe `X-RateLimit-*` e `Retry-After`.‚Äù

### EventBus sem ‚ÄúImportar‚Äù (Mensagem 10)

*   **Aparece no outro app automaticamente.**  
    ‚ÄúAp√≥s persistir, publicar `ReceiptEvent{scope,phase,cid,parent,decision,ts}` em parti√ß√£o `app:tenant`. Os sat√©lites projetam; nada de ‚ÄòImportar Dados‚Äô.‚Äù

### Observabilidade que ensina confian√ßa (Mensagem 11)

*   **Explica a matem√°tica no UI.**  
    ‚ÄúTooltips/poppers mostram **por que** PASS/RETRY/DENY, com links ‚ÄòVerificar‚Äô (abre guia com `ublx verify {cid}` e exemplos TS/Py).‚Äù

### UI do recibo (Mensagem 12)

*   **Teu layout, tua largura, teu PASS gigante.**  
    ‚ÄúMant√©m o ‚ÄòPASS‚Äô grande + selo ‚Äò**UBL Certified Runtime by LogLine Trust**‚Äô. Demo Mode quando sem `cid`. ‚ÄòCopy All‚Äô inclui `links.self`. Modo impress√£o com faixa de autenticidade.‚Äù

* * *

#### Textos prontos pra colar nas mensagens

*   **Msg 2 (Arquitetura base)**  
    ‚ÄúTodas as decis√µes e identidades s√£o **URL-first**: `/{a}/{app}/{t}/{tenant}/‚Ä¶`. Cada artefato √© um **chip** (CID/DID).‚Äù
*   **Msg 3 (Rotas/Escopo)**  
    ‚ÄúEscopo √© extra√≠do **somente** da URL; tokens n√£o carregam escopo autoridade-wise, apenas identidade.‚Äù
*   **Msg 5 (Idempot√™ncia)**  
    ‚ÄúInclui `query_sha` e `contract_rev` na chave para blindar evolu√ß√£o de contrato.‚Äù
*   **Msg 6 (Rate limit)**  
    ‚ÄúToken bucket por m√©todo com `X-RateLimit-*` sempre expostos em CORS; preflight cobre `Origin` exato e `Vary: Origin`.‚Äù
*   **Msg 7 (Receipt API)**  
    ‚Äú`GET` nunca exige `Content-Type`; `b3:` cru e `%3A` s√£o v√°lidos; erros em `AppError` JSON est√°vel.‚Äù
*   **Msg 8 (Battle)**  
    ‚ÄúFluxo can√¥nico **user ‚Üí app ‚Üí tenant** via CLI p√∫blica/admin; sem atalhos. Caso convite por e-mail com sess√£o ativa, aceite 1-clique.‚Äù
*   **Msg 9 (CLI como contrato)**  
    ‚ÄúUI e testes chamam a mesma opera√ß√£o da CLI. Diverg√™ncia vira ‚Äòalignment issue‚Äô com reprodutor.‚Äù
*   **Msg 10 (EventBus)**  
    ‚ÄúPublica **ap√≥s** persistir. Consumidores idempotentes por `cid`.‚Äù
*   **Msg 12 (UI)**  
    ‚ÄúBot√µes helper com feedback t√°til/visual; ‚ÄòVerify‚Äô pulsa a folha e abre guia. Impress√£o s√≥bria com faixa de autenticidade.‚Äù

S
